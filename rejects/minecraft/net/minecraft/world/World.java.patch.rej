++++ REJECTED PATCH 5
 
     public boolean isAirBlock(BlockPos pos)
     {
-        return this.getBlockState(pos).getBlock().getMaterial() == Material.air;
+        return this.getBlockState(pos).getBlock().isAir(this, pos);
     }
 
     public boolean isBlockLoaded(BlockPos pos)
++++ END PATCH
++++ REJECTED PATCH 6
         {
             Chunk chunk = this.getChunkFromBlockCoords(pos);
             Block block = newState.getBlock();
+
+            net.minecraftforge.common.util.BlockSnapshot blockSnapshot = null;
+            if (this.captureBlockSnapshots && !this.isRemote)
+            {
+                blockSnapshot = net.minecraftforge.common.util.BlockSnapshot.getBlockSnapshot(this, pos, flags);
+                this.capturedBlockSnapshots.add(blockSnapshot);
+            }
+            Block oldBlock = getBlockState(pos).getBlock();
+            int oldLight = oldBlock.getLightValue(this, pos);
+            int oldOpacity = oldBlock.getLightOpacity(this, pos);
+
             IBlockState iblockstate = chunk.setBlockState(pos, newState);
 
             if (iblockstate == null)
             {
+                if (blockSnapshot != null) this.capturedBlockSnapshots.remove(blockSnapshot);
                 return false;
             }
             else
             {
                 Block block1 = iblockstate.getBlock();
 
-                if (block.getLightOpacity() != block1.getLightOpacity() || block.getLightValue() != block1.getLightValue())
+                if (block.getLightOpacity(this, pos) != oldOpacity || block.getLightValue(this, pos) != oldLight)
                 {
                     this.theProfiler.startSection("checkLight");
                     this.checkLight(pos);
                     this.theProfiler.endSection();
                 }
 
-                if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && chunk.isPopulated())
+                if (blockSnapshot == null) // Don't notify clients or update physics while capturing blockstates
                 {
-                    this.markBlockForUpdate(pos);
+                    this.markAndNotifyBlock(pos, chunk, iblockstate, newState, flags); // Modularize client and physic updates
                 }
 
+                return true;
+            }
+        }
+    }
+
+    // Split off from original setBlockState(BlockPos, IBlockState Block p_147465_4_, int) method in order to directly send client and physic updates
+    public void markAndNotifyBlock(BlockPos pos, Chunk chunk, IBlockState old, IBlockState new_, int flags)
+    {
+        if ((flags & 2) != 0 && (!this.isRemote || (flags & 4) == 0) && (chunk == null || chunk.isPopulated()))
+        {
+            this.markBlockForUpdate(pos);
+        }
+        {
+            {
                 if (!this.isRemote && (flags & 1) != 0)
                 {
-                    this.notifyNeighborsRespectDebug(pos, iblockstate.getBlock());
+                    this.notifyNeighborsRespectDebug(pos, new_.getBlock());
 
-                    if (block.hasComparatorInputOverride())
+                    if (new_.getBlock().hasComparatorInputOverride())
                     {
-                        this.updateComparatorOutputLevel(pos, block);
+                        this.updateComparatorOutputLevel(pos, new_.getBlock());
                     }
                 }
-
-                return true;
             }
         }
     }
++++ END PATCH
++++ REJECTED PATCH 14
 
     public int calculateSkylightSubtracted(float p_72967_1_)
     {
+        float f = provider.getSunBrightnessFactor(p_72967_1_);
+        f = 1 - f;
+        return (int)(f * 11);
+    }
+
+    /**
+     * The current sun brightness factor for this dimension.
+     * 0.0f means no light at all, and 1.0f means maximum sunlight.
+     * Highly recommended for sunlight detection like solar panel.
+     *
+     * @return The current brightness factor
+     * */
+    public float getSunBrightnessFactor(float p_72967_1_)
+    {
         float f = this.getCelestialAngle(p_72967_1_);
         float f1 = 1.0F - (MathHelper.cos(f * (float)Math.PI * 2.0F) * 2.0F + 0.5F);
         f1 = MathHelper.clamp_float(f1, 0.0F, 1.0F);
         f1 = 1.0F - f1;
         f1 = (float)((double)f1 * (1.0D - (double)(this.getRainStrength(p_72967_1_) * 5.0F) / 16.0D));
         f1 = (float)((double)f1 * (1.0D - (double)(this.getThunderStrength(p_72967_1_) * 5.0F) / 16.0D));
-        f1 = 1.0F - f1;
-        return (int)(f1 * 11.0F);
+        return f1;
     }
 
-    @SideOnly(Side.CLIENT)
     public void removeWorldAccess(IWorldAccess worldAccess)
     {
         this.worldAccesses.remove(worldAccess);
++++ END PATCH
++++ REJECTED PATCH 20
         for (blockpos = new BlockPos(pos.getX(), chunk.getTopFilledSegment() + 16, pos.getZ()); blockpos.getY() >= 0; blockpos = blockpos1)
         {
             blockpos1 = blockpos.down();
-            Material material = chunk.getBlock(blockpos1).getMaterial();
+            Block block = chunk.getBlock(blockpos1);
 
-            if (material.blocksMovement() && material != Material.leaves)
+            if (block.getMaterial().blocksMovement() && !block.isLeaves(this, blockpos1) && !block.isFoliage(this, blockpos1))
             {
                 break;
             }
++++ END PATCH
++++ REJECTED PATCH 23
                     CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     CrashReportCategory crashreportcategory2 = crashreport1.makeCategory("Entity being ticked");
                     entity2.addEntityCrashInfo(crashreportcategory2);
-                    throw new ReportedException(crashreport1);
+                    if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
+                    {
+                        net.minecraftforge.fml.common.FMLLog.severe(crashreport1.getCompleteReport());
+                        removeEntity(entity2);
+                    }
+                    else
+                    {
+                        throw new ReportedException(crashreport1);
+                    }
                 }
             }
 
++++ END PATCH
++++ REJECTED PATCH 24
                         CrashReport crashreport2 = CrashReport.makeCrashReport(throwable, "Ticking block entity");
                         CrashReportCategory crashreportcategory1 = crashreport2.makeCategory("Block entity being ticked");
                         tileentity.addInfoToCrashReport(crashreportcategory1);
-                        throw new ReportedException(crashreport2);
+                        if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities)
+                        {
+                            net.minecraftforge.fml.common.FMLLog.severe(crashreport2.getCompleteReport());
+                            tileentity.invalidate();
+                            this.removeTileEntity(tileentity.getPos());
+                        }
+                        else
+                        {
+                            throw new ReportedException(crashreport2);
+                        }
                     }
                 }
             }
++++ END PATCH
++++ REJECTED PATCH 28
                 {
                     Block block = this.getBlockState(blockpos$mutableblockpos.set(k1, l1, i2)).getBlock();
 
-                    if (block.getMaterial() != Material.air)
+                    if (!block.isAir(this, new BlockPos(k1, l1, i2)))
                     {
                         return true;
                     }
++++ END PATCH
++++ REJECTED PATCH 31
                     IBlockState iblockstate = this.getBlockState(blockpos$mutableblockpos.set(k1, l1, i2));
                     Block block = iblockstate.getBlock();
 
+                    Boolean result = block.isAABBInsideMaterial(this, blockpos$mutableblockpos, bb, materialIn);
+                    if (result != null) return result;
+
                     if (block.getMaterial() == materialIn)
                     {
                         int j2 = ((Integer)iblockstate.getValue(BlockLiquid.LEVEL)).intValue();
++++ END PATCH
++++ REJECTED PATCH 35
     {
         IBlockState iblockstate = blockAccess.getBlockState(pos);
         Block block = iblockstate.getBlock();
-        return block.getMaterial().isOpaque() && block.isFullCube() ? true : (block instanceof BlockStairs ? iblockstate.getValue(BlockStairs.HALF) == BlockStairs.EnumHalf.TOP : (block instanceof BlockSlab ? iblockstate.getValue(BlockSlab.HALF) == BlockSlab.EnumBlockHalf.TOP : (block instanceof BlockHopper ? true : (block instanceof BlockSnow ? ((Integer)iblockstate.getValue(BlockSnow.LAYERS)).intValue() == 7 : false))));
+        return block.isSideSolid(blockAccess, pos, EnumFacing.UP);
     }
 
     public boolean isBlockNormalCube(BlockPos pos, boolean _default)
++++ END PATCH
++++ REJECTED PATCH 36
             else
             {
                 Block block = this.getBlockState(pos).getBlock();
-                return block.getMaterial().isOpaque() && block.isFullCube();
+                return block.isNormalCube(this, pos);
             }
         }
     }
++++ END PATCH
++++ REJECTED PATCH 40
     {
         this.activeChunkSet.clear();
         this.theProfiler.startSection("buildList");
+        this.activeChunkSet.addAll(getPersistentChunks().keySet());
 
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
++++ END PATCH
++++ REJECTED PATCH 41
             Block block = chunkIn.getBlock(blockpos);
             j = j + p_147467_1_;
             k = k + p_147467_2_;
+            BlockPos worldpos = blockpos.add(p_147467_1_, 0, p_147467_2_);
 
-            if (block.getMaterial() == Material.air && this.getLight(blockpos) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, blockpos) <= 0)
+            if (block.isAir(this, worldpos) && this.getLight(worldpos) <= this.rand.nextInt(8) && this.getLightFor(EnumSkyBlock.SKY, worldpos) <= 0) //Forge: isAir, and fix arguments to world positions instead of chunk position
             {
                 EntityPlayer entityplayer = this.getClosestPlayer((double)j + 0.5D, (double)l + 0.5D, (double)k + 0.5D, 8.0D);
 
++++ END PATCH
++++ REJECTED PATCH 44
             {
                 Block block = this.getBlockState(pos).getBlock();
 
-                if (block.getMaterial() == Material.air && Blocks.snow_layer.canPlaceBlockAt(this, pos))
+                if (block.isAir(this, pos) && Blocks.snow_layer.canPlaceBlockAt(this, pos))
                 {
                     return true;
                 }
++++ END PATCH
++++ REJECTED PATCH 45
         else
         {
             Block block = this.getBlockState(pos).getBlock();
-            int i = lightType == EnumSkyBlock.SKY ? 0 : block.getLightValue();
-            int j = block.getLightOpacity();
+            int blockLight = block.getLightValue(this, pos);
+            int i = lightType == EnumSkyBlock.SKY ? 0 : blockLight;
+            int j = block.getLightOpacity(this, pos);
 
-            if (j >= 15 && block.getLightValue() > 0)
+            if (j >= 15 && blockLight > 0)
             {
                 j = 1;
             }
++++ END PATCH
++++ REJECTED PATCH 47
 
     public <T extends Entity> List<T> getEntitiesWithinAABB(Class <? extends T > clazz, AxisAlignedBB aabb, Predicate <? super T > filter)
     {
-        int i = MathHelper.floor_double((aabb.minX - 2.0D) / 16.0D);
-        int j = MathHelper.floor_double((aabb.maxX + 2.0D) / 16.0D);
-        int k = MathHelper.floor_double((aabb.minZ - 2.0D) / 16.0D);
-        int l = MathHelper.floor_double((aabb.maxZ + 2.0D) / 16.0D);
+        int i = MathHelper.floor_double((aabb.minX - MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor_double((aabb.maxX + MAX_ENTITY_RADIUS) / 16.0D);
+        int k = MathHelper.floor_double((aabb.minZ - MAX_ENTITY_RADIUS) / 16.0D);
+        int l = MathHelper.floor_double((aabb.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
         List<T> list = Lists.<T>newArrayList();
 
         for (int i1 = i; i1 <= j; ++i1)
++++ END PATCH
++++ REJECTED PATCH 49
     {
         Block block = this.getBlockState(pos).getBlock();
         AxisAlignedBB axisalignedbb = p_175716_3_ ? null : blockIn.getCollisionBoundingBox(this, pos, blockIn.getDefaultState());
-        return axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, entityIn) ? false : (block.getMaterial() == Material.circuits && blockIn == Blocks.anvil ? true : block.getMaterial().isReplaceable() && blockIn.canReplace(this, pos, side, itemStackIn));
+        if (axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, entityIn)) return false;
+        if (block.getMaterial() == Material.circuits && blockIn == Blocks.anvil) return true;
+        return block.isReplaceable(this, pos) && blockIn.canReplace(this, pos, side, itemStackIn);
     }
 
     public int getSeaLevel()
++++ END PATCH
++++ REJECTED PATCH 50
     {
         IBlockState iblockstate = this.getBlockState(pos);
         Block block = iblockstate.getBlock();
-        return block.isNormalCube() ? this.getStrongPower(pos) : block.getWeakPower(this, pos, iblockstate, facing);
+        return block.shouldCheckWeakPower(this, pos, facing) ? this.getStrongPower(pos) : block.getWeakPower(this, pos, iblockstate, facing);
     }
 
     public boolean isBlockPowered(BlockPos pos)
++++ END PATCH
++++ REJECTED PATCH 59
             {
                 IBlockState iblockstate = this.getBlockState(blockpos);
 
-                if (Blocks.unpowered_comparator.isAssociated(iblockstate.getBlock()))
+                iblockstate.getBlock().onNeighborChange(this, blockpos, pos);
+                if (iblockstate.getBlock().isNormalCube(this, blockpos))
                 {
-                    iblockstate.getBlock().onNeighborBlockChange(this, blockpos, iblockstate, blockIn);
-                }
-                else if (iblockstate.getBlock().isNormalCube())
-                {
-                    blockpos = blockpos.offset(enumfacing);
-                    iblockstate = this.getBlockState(blockpos);
-
-                    if (Blocks.unpowered_comparator.isAssociated(iblockstate.getBlock()))
+                    BlockPos posOther = blockpos.offset(enumfacing);
+                    Block other = getBlockState(posOther).getBlock();
+                    if (other.getWeakChanges(this, posOther))
                     {
-                        iblockstate.getBlock().onNeighborBlockChange(this, blockpos, iblockstate, blockIn);
+                        other.onNeighborChange(this, posOther, pos);
                     }
                 }
             }
++++ END PATCH
