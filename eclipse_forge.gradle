import net.minecraftforge.forge.tasks.CleanProperties

apply plugin: 'eclipse'

// We need to write the manifest to the binary file so we have properly versioned packaged at dev time.
tasks.register('writeManifest') {
    doLast {
        universalJar.manifest.writeTo(rootProject.file('src/main/resources/META-INF/MANIFEST.MF'))
    }
}

tasks.register('copyEclipseSettings') {
    doLast {
        rootProject.fileTree('ide/eclipse/template/.settings/')
        .matching { include '**/*.prefs' }
        .each { file ->
            def target = project.file('.settings/' + file.name)
            def temp = new CleanProperties().load(file)
            def exst = new CleanProperties().load(target)
            exst.put('eclipse.preferences.version', '1')
            temp.forEach(exst::put)
            exst.store(target)
        }
    }
}

// TODO: [Gradle][IntelliJ] Auto trigger these tasks on import.
eclipse {
    // Run everytime eclipse builds the code
    //synchronizationTasks(writeManifest)
    // Run when importing the project
    synchronizationTasks(writeManifest, copyEclipseSettings, 'genEclipseRuns')
}

eclipse {
    classpath.file.whenMerged {
        def minecraft = entries.find { it.path == 'src/main/java' }
        // Disable optional warnings on the minecraft decompiled source code. It just muddies the warning window and hides warnings in our own codebase
        minecraft.entryAttributes['ignore_optional_problems'] = 'true'
        
        def mods = [
            'src/main/java':      'minecraft',
            'src/main/resources': 'minecraft',
            'src/test/java':      'minecraft-test',
            'src/test/resources': 'minecraft-test',
            
            'main-java':      'forge',
            'main-resources': 'forge',
            'generated':      'forge',
            
            'test-java':      'forge-test',
            'test-resources': 'forge-test',
            'test-generated': 'forge-test',
        ]
        
        entries.forEach { e -> 
            // TODO: [Gradle][IntelliJ] Make sure that the output merges both bin and resources into one folder so we don't need the UnionFileSystem
            // Seperate their output folders by mod
            if ('src'.equals(e.kind) && e.hasProperty('output')) {
                if (mods.containsKey(e.path))
                    e.output = 'bin/' + mods[e.path]
                else
                    throw new IllegalStateException('Unknown path: ' + e.toString())
            }
        }
    }
    
    /* This is unreliable for some reason so don't bother 
    // Eclipse names don't group properly so rename them to something nice.
    def renames = [
        'main-java': 'forge',
        'resources': 'forge-resources',
        'test-java': 'test',
        'generated-resources': 'forge-generated',
        'generated_test-resources': 'test-generated'
    ]
    
    project.file.whenMerged {
        linkedResources.forEach { e -> e.name = renames.getOrDefault(e.name, e.name) }
        linkedResources.sort()
    }
    
    classpath.file.whenMerged {
        entries.forEach { e -> e.path = renames.getOrDefault(e.path, e.path) }
        
        def kinds = ['output', 'src', 'con', 'lib', 'var']
        // Sort the entries just to make it group nicer in the IDE
        entries.sort { a,b ->
            if (!a.kind.equals(b.kind))
                return kinds.indexOf(a.kind) - kinds.indexOf(b.kind)
            if (!'src'.equals(a.kind)) return  0
            // I want vanilla source at the top
            if (a == minecraft) return -1
            if (b == minecraft) return  1
            return a.path.compareTo(b.path)
        }
    }
    */
    
    // Filter out the run directory
    project.resourceFilter {
        appliesTo = 'FOLDERS'
        type = 'EXCLUDE_ALL'
        matcher {
            id = 'org.eclipse.ui.ide.multiFilter'
            arguments = '1.0-name-matches-false-true-run'
        }
    }
}