--- ../src_base/minecraft/net/minecraft/entity/player/EntityPlayer.java
+++ ../src_work/minecraft/net/minecraft/entity/player/EntityPlayer.java
@@ -5,8 +5,11 @@
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map.Entry;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
 import net.minecraft.block.material.Material;
@@ -68,8 +71,35 @@
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.IChunkProvider;
 
-public abstract class EntityPlayer extends EntityLivingBase implements ICommandSender
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.common.ISpecialArmor.ArmorProperties;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.ForgeEventFactory;
+import net.minecraftforge.event.entity.living.LivingHurtEvent;
+import net.minecraftforge.event.entity.player.AttackEntityEvent;
+import net.minecraftforge.event.entity.player.EntityInteractEvent;
+import net.minecraftforge.event.entity.player.PlayerDestroyItemEvent;
+import net.minecraftforge.event.entity.player.PlayerDropsEvent;
+import net.minecraftforge.event.entity.player.PlayerFlyableFallEvent;
+import net.minecraftforge.event.entity.player.PlayerSleepInBedEvent;
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftHumanEntity;
+import org.bukkit.craftbukkit.entity.CraftItem;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import org.bukkit.event.player.PlayerBedEnterEvent;
+import org.bukkit.event.player.PlayerBedLeaveEvent;
+import org.bukkit.event.player.PlayerDropItemEvent;
+import org.bukkit.event.player.PlayerItemConsumeEvent;
+import net.minecraft.network.packet.Packet103SetSlot;
+// CraftBukkit end
+
+public abstract class EntityPlayer extends EntityLivingBase implements ICommandSender, cpw.mods.fml.common.network.Player // MCPC+ - marker interface
 {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
     /** Inventory of the player */
     public InventoryPlayer inventory = new InventoryPlayer(this);
     private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest();
@@ -104,15 +134,25 @@
     public double field_71094_bP;
     public double field_71095_bQ;
     public double field_71085_bR;
+    // CraftBukkit start
 
     /** Boolean value indicating weather a player is sleeping or not */
-    protected boolean sleeping;
+    public boolean sleeping; // protected -> public
+    public boolean fauxSleeping;
+    public String spawnWorld = "";
+
+    @Override
+    public CraftHumanEntity getBukkitEntity()
+    {
+        return (CraftHumanEntity) super.getBukkitEntity();
+    }
+    // CraftBukkit end
 
     /**
      * The chunk coordinates of the bed the player is in (null if player isn't in a bed).
      */
     public ChunkCoordinates playerLocation;
-    public int sleepTimer;
+    public int sleepTimer; // CraftBukkit - private -> public
     public float field_71079_bU;
     @SideOnly(Side.CLIENT)
     public float field_71082_cx;
@@ -122,17 +162,20 @@
      * Holds the last coordinate to spawn based on last bed that the player sleep.
      */
     private ChunkCoordinates spawnChunk;
+    private HashMap<Integer, ChunkCoordinates> spawnChunkMap = new HashMap<Integer, ChunkCoordinates>();
 
     /**
      * Whether this player's spawn point is forced, preventing execution of bed checks.
      */
     private boolean spawnForced;
+    private HashMap<Integer, Boolean> spawnForcedMap = new HashMap<Integer, Boolean>();
 
     /** Holds the coordinate of the player when enter a minecraft to ride. */
     private ChunkCoordinates startMinecartRidingCoordinate;
 
     /** The player's capabilities. (See class PlayerCapabilities) */
     public PlayerCapabilities capabilities = new PlayerCapabilities();
+    public int oldLevel = -1; // CraftBukkit
 
     /** The current experience level the player is on. */
     public int experienceLevel;
@@ -269,6 +312,7 @@
 
             if (itemstack == this.itemInUse)
             {
+                itemInUse.getItem().onUsingItemTick(itemInUse, this, itemInUseCount);
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(itemstack, 5);
@@ -447,6 +491,36 @@
         {
             this.updateItemUse(this.itemInUse, 16);
             int i = this.itemInUse.stackSize;
+            // CraftBukkit start
+            org.bukkit.inventory.ItemStack craftItem = CraftItemStack.asBukkitCopy(this.itemInUse);
+            PlayerItemConsumeEvent event = new PlayerItemConsumeEvent((Player) this.getBukkitEntity(), craftItem);
+            worldObj.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled())
+            {
+                // Update client
+                if (this instanceof EntityPlayerMP)
+                {
+                    ((EntityPlayerMP) this).playerNetServerHandler.sendPacketToPlayer(new Packet103SetSlot((byte) 0, openContainer.getSlotFromInventory((IInventory) this.inventory, this.inventory.currentItem).slotIndex, this.itemInUse));
+                }
+
+                return;
+            }
+
+            // Plugin modified the item, process it but don't remove it
+            if (!craftItem.equals(event.getItem()))
+            {
+                CraftItemStack.asNMSCopy(event.getItem()).onFoodEaten(this.worldObj, this);
+
+                // Update client
+                if (this instanceof EntityPlayerMP)
+                {
+                    ((EntityPlayerMP) this).playerNetServerHandler.sendPacketToPlayer(new Packet103SetSlot((byte) 0, openContainer.getSlotFromInventory((IInventory) this.inventory, this.inventory.currentItem).slotIndex, this.itemInUse));
+                }
+
+                return;
+            }
+            // CraftBukkit end
             ItemStack itemstack = this.itemInUse.onFoodEaten(this.worldObj, this);
 
             if (itemstack != this.itemInUse || itemstack != null && itemstack.stackSize != i)
@@ -497,7 +571,14 @@
      */
     public void mountEntity(Entity par1Entity)
     {
-        if (this.ridingEntity != null && par1Entity == null)
+        // CraftBukkit start - mirror Entity mount changes
+        this.setPassengerOf(par1Entity);
+    }
+
+    public void setPassengerOf(Entity entity)
+    {
+        // CraftBukkit end
+        if (this.ridingEntity != null && entity == null)
         {
             if (!this.worldObj.isRemote)
             {
@@ -513,7 +594,7 @@
         }
         else
         {
-            super.mountEntity(par1Entity);
+            super.setPassengerOf(entity); // CraftBukkit - call new parent
         }
     }
 
@@ -539,11 +620,11 @@
             this.cameraYaw = 0.0F;
             this.addMountedMovementStat(this.posX - d0, this.posY - d1, this.posZ - d2);
 
-            if (this.ridingEntity instanceof EntityPig)
+            if (this.ridingEntity instanceof EntityLivingBase && ((EntityLivingBase)ridingEntity).shouldRiderFaceForward(this))
             {
                 this.rotationPitch = f1;
                 this.rotationYaw = f;
-                this.renderYawOffset = ((EntityPig)this.ridingEntity).renderYawOffset;
+                this.renderYawOffset = ((EntityLivingBase)this.ridingEntity).renderYawOffset;
             }
         }
     }
@@ -582,7 +663,8 @@
 
         if (this.worldObj.difficultySetting == 0 && this.func_110143_aJ() < this.func_110138_aP() && this.worldObj.getGameRules().getGameRuleBooleanValue("naturalRegeneration") && this.ticksExisted % 20 * 12 == 0)
         {
-            this.heal(1.0F);
+            // CraftBukkit - added regain reason of "REGEN" for filtering purposes.
+            this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN);
         }
 
         this.inventory.decrementAnimations();
@@ -604,7 +686,7 @@
 
         this.setAIMoveSpeed((float)attributeinstance.func_111126_e());
         float f = MathHelper.sqrt_double(this.motionX * this.motionX + this.motionZ * this.motionZ);
-        float f1 = (float)Math.atan(-this.motionY * 0.20000000298023224D) * 15.0F;
+        float f1 = (float) org.bukkit.craftbukkit.TrigMath.atan(-this.motionY * 0.20000000298023224D) * 15.0F;  // CraftBukkit - Math -> TrigMath
 
         if (f > 0.1F)
         {
@@ -686,11 +768,15 @@
      */
     public void onDeath(DamageSource par1DamageSource)
     {
+        if (ForgeHooks.onLivingDeath(this, par1DamageSource)) return;
         super.onDeath(par1DamageSource);
         this.setSize(0.2F, 0.2F);
         this.setPosition(this.posX, this.posY, this.posZ);
         this.motionY = 0.10000000149011612D;
 
+        captureDrops = true;
+        capturedDrops.clear();
+
         if (this.username.equals("Notch"))
         {
             this.dropPlayerItemWithRandomChoice(new ItemStack(Item.appleRed, 1), true);
@@ -699,6 +785,20 @@
         if (!this.worldObj.getGameRules().getGameRuleBooleanValue("keepInventory"))
         {
             this.inventory.dropAllItems();
+        }
+
+        captureDrops = false;
+
+        if (!worldObj.isRemote)
+        {
+            PlayerDropsEvent event = new PlayerDropsEvent(this, par1DamageSource, capturedDrops, recentlyHit > 0);
+            if (!MinecraftForge.EVENT_BUS.post(event))
+            {
+                for (EntityItem item : capturedDrops)
+                {
+                    joinEntityItemWithWorld(item);
+                }
+            }
         }
 
         if (par1DamageSource != null)
@@ -722,12 +822,14 @@
     public void addToPlayerScore(Entity par1Entity, int par2)
     {
         this.addScore(par2);
-        Collection collection = this.getWorldScoreboard().func_96520_a(ScoreObjectiveCriteria.field_96640_e);
+        // CraftBukkit - Get our scores instead
+        Collection<Score> collection = this.worldObj.getServer().getScoreboardManager().getScoreboardScores(ScoreObjectiveCriteria.field_96640_e, this.getEntityName(), new java.util.ArrayList<Score>());
 
         if (par1Entity instanceof EntityPlayer)
         {
             this.addStat(StatList.playerKillsStat, 1);
-            collection.addAll(this.getWorldScoreboard().func_96520_a(ScoreObjectiveCriteria.field_96639_d));
+            // CraftBukkit - Get our scores instead
+            this.worldObj.getServer().getScoreboardManager().getScoreboardScores(ScoreObjectiveCriteria.field_96639_d, this.getEntityName(), collection);
         }
         else
         {
@@ -738,8 +840,7 @@
 
         while (iterator.hasNext())
         {
-            ScoreObjective scoreobjective = (ScoreObjective)iterator.next();
-            Score score = this.getWorldScoreboard().func_96529_a(this.getEntityName(), scoreobjective);
+            Score score = (Score) iterator.next(); // CraftBukkit - Use our scores instead
             score.func_96648_a();
         }
     }
@@ -749,7 +850,20 @@
      */
     public EntityItem dropOneItem(boolean par1)
     {
-        return this.dropPlayerItemWithRandomChoice(this.inventory.decrStackSize(this.inventory.currentItem, par1 && this.inventory.getCurrentItem() != null ? this.inventory.getCurrentItem().stackSize : 1), false);
+        ItemStack stack = inventory.getCurrentItem();
+
+        if (stack == null)
+        {
+            return null;
+        }
+
+        if (stack.getItem().onDroppedByPlayer(stack, this))
+        {
+            int count = par1 && this.inventory.getCurrentItem() != null ? this.inventory.getCurrentItem().stackSize : 1;
+            return ForgeHooks.onPlayerTossEvent(this, inventory.decrStackSize(inventory.currentItem, count));
+        }
+
+        return null;
     }
 
     /**
@@ -758,7 +872,7 @@
      */
     public EntityItem dropPlayerItem(ItemStack par1ItemStack)
     {
-        return this.dropPlayerItemWithRandomChoice(par1ItemStack, false);
+        return ForgeHooks.onPlayerTossEvent(this, par1ItemStack);
     }
 
     /**
@@ -803,6 +917,18 @@
                 entityitem.motionZ += Math.sin((double)f1) * (double)f;
             }
 
+            // CraftBukkit start
+            Player player = (Player) this.getBukkitEntity();
+            CraftItem drop = new CraftItem(this.worldObj.getServer(), entityitem);
+            PlayerDropItemEvent event = new PlayerDropItemEvent(player, drop);
+            this.worldObj.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled())
+            {
+                player.getInventory().addItem(drop.getItemStack());
+                return null;
+            }
+            // CraftBukkit end
             this.joinEntityItemWithWorld(entityitem);
             this.addStat(StatList.dropStat, 1);
             return entityitem;
@@ -814,15 +940,28 @@
      */
     public void joinEntityItemWithWorld(EntityItem par1EntityItem)
     {
+        if (captureDrops)
+        {
+            capturedDrops.add(par1EntityItem);
+            return;
+        }
         this.worldObj.spawnEntityInWorld(par1EntityItem);
     }
 
     /**
      * Returns how strong the player is against the specified block at this moment
-     */
+     * Deprecated in favor of the more sensitive version
+     */
+    @Deprecated
     public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2)
     {
-        float f = this.inventory.getStrVsBlock(par1Block);
+        return getCurrentPlayerStrVsBlock(par1Block, par2, 0);
+    }
+
+    public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2, int meta)
+    {
+        ItemStack stack = inventory.getCurrentItem();
+        float f = (stack == null ? 1.0F : stack.getItem().getStrVsBlock(stack, par1Block, meta));
 
         if (f > 1.0F)
         {
@@ -833,7 +972,9 @@
             {
                 float f1 = (float)(i * i + 1);
 
-                if (!itemstack.canHarvestBlock(par1Block) && f <= 1.0F)
+                boolean canHarvest = ForgeHooks.canToolHarvestBlock(par1Block, meta, itemstack);
+
+                if (!canHarvest && f <= 1.0F)
                 {
                     f += f1 * 0.08F;
                 }
@@ -864,7 +1005,8 @@
             f /= 5.0F;
         }
 
-        return f;
+        f = ForgeEventFactory.getBreakSpeed(this, par1Block, meta, f);
+        return (f < 0 ? 0 : f);
     }
 
     /**
@@ -872,7 +1014,7 @@
      */
     public boolean canHarvestBlock(Block par1Block)
     {
-        return this.inventory.canHarvestBlock(par1Block);
+        return ForgeEventFactory.doPlayerHarvestCheck(this, par1Block, inventory.canHarvestBlock(par1Block));
     }
 
     /**
@@ -897,10 +1039,26 @@
             this.wakeUpPlayer(true, true, false);
         }
 
+        // CraftBukkit start
+        this.spawnWorld = par1NBTTagCompound.getString("SpawnWorld");
+
+        if ("".equals(spawnWorld))
+        {
+            this.spawnWorld = this.worldObj.getServer().getWorlds().get(0).getName();
+        }
+        // CraftBukkit end
         if (par1NBTTagCompound.hasKey("SpawnX") && par1NBTTagCompound.hasKey("SpawnY") && par1NBTTagCompound.hasKey("SpawnZ"))
         {
             this.spawnChunk = new ChunkCoordinates(par1NBTTagCompound.getInteger("SpawnX"), par1NBTTagCompound.getInteger("SpawnY"), par1NBTTagCompound.getInteger("SpawnZ"));
             this.spawnForced = par1NBTTagCompound.getBoolean("SpawnForced");
+        }
+        NBTTagList spawnlist = null;
+        spawnlist = par1NBTTagCompound.getTagList("Spawns");
+        for (int i = 0; i < spawnlist.tagCount(); ++i) {
+            NBTTagCompound spawndata = (NBTTagCompound)spawnlist.tagAt(i);
+            int spawndim = spawndata.getInteger("Dim");
+            this.spawnChunkMap.put(spawndim, new ChunkCoordinates(spawndata.getInteger("SpawnX"), spawndata.getInteger("SpawnY"), spawndata.getInteger("SpawnZ")));
+            this.spawnForcedMap.put(spawndim, spawndata.getBoolean("SpawnForced"));
         }
 
         this.foodStats.readNBT(par1NBTTagCompound);
@@ -934,7 +1092,23 @@
             par1NBTTagCompound.setInteger("SpawnY", this.spawnChunk.posY);
             par1NBTTagCompound.setInteger("SpawnZ", this.spawnChunk.posZ);
             par1NBTTagCompound.setBoolean("SpawnForced", this.spawnForced);
-        }
+            par1NBTTagCompound.setString("SpawnWorld", spawnWorld); // CraftBukkit - fixes bed spawns for multiworld worlds
+        }
+        NBTTagList spawnlist = new NBTTagList();
+        for (Entry<Integer, ChunkCoordinates> entry : this.spawnChunkMap.entrySet()) {
+            NBTTagCompound spawndata = new NBTTagCompound();
+            ChunkCoordinates spawn = entry.getValue();
+            if (spawn == null) continue;
+            Boolean forced = spawnForcedMap.get(entry.getKey());
+            if (forced == null) forced = false;
+            spawndata.setInteger("Dim", entry.getKey());
+            spawndata.setInteger("SpawnX", spawn.posX);
+            spawndata.setInteger("SpawnY", spawn.posY);
+            spawndata.setInteger("SpawnZ", spawn.posZ);
+            spawndata.setBoolean("SpawnForced", forced);
+            spawnlist.appendTag(spawndata);
+        }
+        par1NBTTagCompound.setTag("Spawns", spawnlist);
 
         this.foodStats.writeNBT(par1NBTTagCompound);
         this.capabilities.writeCapabilitiesToNBT(par1NBTTagCompound);
@@ -982,6 +1156,7 @@
      */
     public boolean attackEntityFrom(DamageSource par1DamageSource, float par2)
     {
+        if (ForgeHooks.onLivingAttack(this, par1DamageSource, par2)) return false;
         if (this.isEntityInvulnerable())
         {
             return false;
@@ -1009,7 +1184,7 @@
                 {
                     if (this.worldObj.difficultySetting == 0)
                     {
-                        par2 = 0.0F;
+                        return false; // CraftBukkit - i = 0 -> return false
                     }
 
                     if (this.worldObj.difficultySetting == 1)
@@ -1023,7 +1198,7 @@
                     }
                 }
 
-                if (par2 == 0.0F)
+                if (false && par2 == 0.0F)   // CraftBukkit - Don't filter out 0 damage
                 {
                     return false;
                 }
@@ -1050,9 +1225,39 @@
 
     public boolean func_96122_a(EntityPlayer par1EntityPlayer)
     {
-        ScorePlayerTeam scoreplayerteam = this.getTeam();
-        ScorePlayerTeam scoreplayerteam1 = par1EntityPlayer.getTeam();
-        return scoreplayerteam != scoreplayerteam1 ? true : (scoreplayerteam != null ? scoreplayerteam.func_96665_g() : true);
+        // CraftBukkit start - Change to check OTHER player's scoreboard team according to API
+        // To summarize this method's logic, it's "Can parameter hurt this"
+        org.bukkit.scoreboard.Team team;
+
+        if (par1EntityPlayer instanceof EntityPlayerMP)
+        {
+            EntityPlayerMP thatPlayer = (EntityPlayerMP) par1EntityPlayer;
+            team = thatPlayer.getBukkitEntity().getScoreboard().getPlayerTeam(thatPlayer.getBukkitEntity());
+
+            if (team == null || team.allowFriendlyFire())
+            {
+                return true;
+            }
+        }
+        else
+        {
+            // This should never be called, but is implemented anyway
+            org.bukkit.OfflinePlayer thisPlayer = par1EntityPlayer.worldObj.getServer().getOfflinePlayer(par1EntityPlayer.username);
+            team = par1EntityPlayer.worldObj.getServer().getScoreboardManager().getMainScoreboard().getPlayerTeam(thisPlayer);
+
+            if (team == null || team.allowFriendlyFire())
+            {
+                return true;
+            }
+        }
+
+        if (this instanceof EntityPlayerMP)
+        {
+            return !team.hasPlayer(((EntityPlayerMP) this).getBukkitEntity());
+        }
+
+        return !team.hasPlayer(this.worldObj.getServer().getOfflinePlayer(this.username));
+        // CraftBukkit end
     }
 
     /**
@@ -1135,12 +1340,15 @@
     {
         if (!this.isEntityInvulnerable())
         {
+            par2 = ForgeHooks.onLivingHurt(this, par1DamageSource, par2);
+            if (par2 <= 0) return;
             if (!par1DamageSource.isUnblockable() && this.isBlocking() && par2 > 0.0F)
             {
                 par2 = (1.0F + par2) * 0.5F;
             }
 
-            par2 = this.applyArmorCalculations(par1DamageSource, par2);
+            par2 = ArmorProperties.ApplyArmor(this, inventory.armorInventory, par1DamageSource, par2);
+            if (par2 <= 0) return;
             par2 = this.applyPotionDamageCalculations(par1DamageSource, par2);
             float f1 = par2;
             par2 = Math.max(par2 - this.func_110139_bj(), 0.0F);
@@ -1190,6 +1398,7 @@
 
     public boolean interactWith(Entity par1Entity)
     {
+        if (MinecraftForge.EVENT_BUS.post(new EntityInteractEvent(this, par1Entity))) return false;
         ItemStack itemstack = this.getCurrentEquippedItem();
         ItemStack itemstack1 = itemstack != null ? itemstack.copy() : null;
 
@@ -1204,7 +1413,8 @@
 
                 if (itemstack.func_111282_a(this, (EntityLivingBase)par1Entity))
                 {
-                    if (itemstack.stackSize <= 0 && !this.capabilities.isCreativeMode)
+                    // CraftBukkit - bypass infinite items; <= 0 -> == 0
+                    if (itemstack.stackSize == 0 && !this.capabilities.isCreativeMode)
                     {
                         this.destroyCurrentEquippedItem();
                     }
@@ -1246,7 +1456,9 @@
      */
     public void destroyCurrentEquippedItem()
     {
+        ItemStack orig = getCurrentEquippedItem();
         this.inventory.setInventorySlotContents(this.inventory.currentItem, (ItemStack)null);
+        MinecraftForge.EVENT_BUS.post(new PlayerDestroyItemEvent(this, orig));
     }
 
     /**
@@ -1263,6 +1475,15 @@
      */
     public void attackTargetEntityWithCurrentItem(Entity par1Entity)
     {
+        if (MinecraftForge.EVENT_BUS.post(new AttackEntityEvent(this, par1Entity)))
+        {
+            return;
+        }
+        ItemStack stack = getCurrentEquippedItem();
+        if (stack != null && stack.getItem().onLeftClickEntity(stack, this, par1Entity))
+        {
+            return;
+        }
         if (par1Entity.canAttackWithItem())
         {
             if (!par1Entity.func_85031_j(this))
@@ -1302,6 +1523,19 @@
                     }
 
                     boolean flag2 = par1Entity.attackEntityFrom(DamageSource.causePlayerDamage(this), f);
+
+                    // CraftBukkit start - Return when the damage fails so that the item will not lose durability
+                    if (!flag2)
+                    {
+                        if (flag1)
+                        {
+                            par1Entity.extinguish();
+                        }
+
+                        return;
+                    }
+
+                    // CraftBukkit end
 
                     if (flag2)
                     {
@@ -1353,7 +1587,8 @@
                     {
                         itemstack.hitEntity((EntityLivingBase)object, this);
 
-                        if (itemstack.stackSize <= 0)
+                        // CraftBukkit - bypass infinite items; <= 0 -> == 0
+                        if (itemstack.stackSize == 0)
                         {
                             this.destroyCurrentEquippedItem();
                         }
@@ -1370,7 +1605,15 @@
 
                         if (j > 0 && flag2)
                         {
-                            par1Entity.setFire(j * 4);
+                            // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                            EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), par1Entity.getBukkitEntity(), j * 4);
+                            org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                            if (!combustEvent.isCancelled())
+                            {
+                                par1Entity.setFire(combustEvent.getDuration());
+                            }
+                            // CraftBukkit end
                         }
                         else if (flag1)
                         {
@@ -1404,6 +1647,10 @@
 
         if (this.openContainer != null)
         {
+            // CraftBukkit start
+            InventoryCloseEvent event = new InventoryCloseEvent(this.openContainer.getBukkitView());
+            if (this.openContainer.getBukkitView() != null) Bukkit.getServer().getPluginManager().callEvent(event); // MCPC+ - allow vanilla mods to bypass
+            // CraftBukkit end
             this.openContainer.onCraftGuiClosed(this);
         }
     }
@@ -1421,6 +1668,12 @@
      */
     public EnumStatus sleepInBedAt(int par1, int par2, int par3)
     {
+        PlayerSleepInBedEvent event = new PlayerSleepInBedEvent(this, par1, par2, par3);
+        MinecraftForge.EVENT_BUS.post(event);
+        if (event.result != null)
+        {
+            return event.result;
+        }
         if (!this.worldObj.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
@@ -1458,6 +1711,21 @@
             this.mountEntity((Entity)null);
         }
 
+        // CraftBukkit start
+        if (this.getBukkitEntity() instanceof Player)
+        {
+            Player player = (Player) this.getBukkitEntity();
+            org.bukkit.block.Block bed = this.worldObj.getWorld().getBlockAt(par1, par2, par3);
+            PlayerBedEnterEvent bedEvent = new PlayerBedEnterEvent(player, bed);
+            this.worldObj.getServer().getPluginManager().callEvent(bedEvent);
+
+            if (bedEvent.isCancelled())
+            {
+                return EnumStatus.OTHER_PROBLEM;
+            }
+        }
+        // CraftBukkit end
+
         this.setSize(0.2F, 0.2F);
         this.yOffset = 0.2F;
 
@@ -1465,6 +1733,11 @@
         {
             int l = this.worldObj.getBlockMetadata(par1, par2, par3);
             int i1 = BlockBed.getDirection(l);
+            Block block = Block.blocksList[worldObj.getBlockId(par1, par2, par3)];
+            if (block != null)
+            {
+                i1 = block.getBedDirection(worldObj, par1, par2, par3);
+            }
             float f = 0.5F;
             float f1 = 0.5F;
 
@@ -1535,10 +1808,12 @@
         ChunkCoordinates chunkcoordinates = this.playerLocation;
         ChunkCoordinates chunkcoordinates1 = this.playerLocation;
 
-        if (chunkcoordinates != null && this.worldObj.getBlockId(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ) == Block.bed.blockID)
-        {
-            BlockBed.setBedOccupied(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, false);
-            chunkcoordinates1 = BlockBed.getNearestEmptyChunkCoordinates(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, 0);
+        Block block = (chunkcoordinates == null ? null : Block.blocksList[worldObj.getBlockId(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ)]);
+
+        if (chunkcoordinates != null && block != null && block.isBed(worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this))
+        {
+            block.setBedOccupied(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this, false);
+            chunkcoordinates1 = block.getBedSpawnPosition(worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this);
 
             if (chunkcoordinates1 == null)
             {
@@ -1555,6 +1830,25 @@
             this.worldObj.updateAllPlayersSleepingFlag();
         }
 
+        // CraftBukkit start
+        if (this.getBukkitEntity() instanceof Player)
+        {
+            Player player = (Player) this.getBukkitEntity();
+            org.bukkit.block.Block bed;
+
+            if (chunkcoordinates != null)
+            {
+                bed = this.worldObj.getWorld().getBlockAt(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ);
+            }
+            else
+            {
+                bed = this.worldObj.getWorld().getBlockAt(player.getLocation());
+            }
+
+            PlayerBedLeaveEvent event = new PlayerBedLeaveEvent(player, bed);
+            this.worldObj.getServer().getPluginManager().callEvent(event);
+        }
+        // CraftBukkit end
         if (par1)
         {
             this.sleepTimer = 0;
@@ -1575,7 +1869,9 @@
      */
     private boolean isInBed()
     {
-        return this.worldObj.getBlockId(this.playerLocation.posX, this.playerLocation.posY, this.playerLocation.posZ) == Block.bed.blockID;
+        ChunkCoordinates c = playerLocation;
+        int blockID = worldObj.getBlockId(c.posX, c.posY, c.posZ);
+        return Block.blocksList[blockID] != null && Block.blocksList[blockID].isBed(worldObj, c.posX, c.posY, c.posZ, this);
     }
 
     /**
@@ -1590,9 +1886,12 @@
         ichunkprovider.loadChunk(par1ChunkCoordinates.posX - 3 >> 4, par1ChunkCoordinates.posZ + 3 >> 4);
         ichunkprovider.loadChunk(par1ChunkCoordinates.posX + 3 >> 4, par1ChunkCoordinates.posZ + 3 >> 4);
 
-        if (par0World.getBlockId(par1ChunkCoordinates.posX, par1ChunkCoordinates.posY, par1ChunkCoordinates.posZ) == Block.bed.blockID)
-        {
-            ChunkCoordinates chunkcoordinates1 = BlockBed.getNearestEmptyChunkCoordinates(par0World, par1ChunkCoordinates.posX, par1ChunkCoordinates.posY, par1ChunkCoordinates.posZ, 0);
+        ChunkCoordinates c = par1ChunkCoordinates;
+        Block block = Block.blocksList[par0World.getBlockId(c.posX, c.posY, c.posZ)];
+
+        if (block != null && block.isBed(par0World, c.posX, c.posY, c.posZ, null))
+        {
+            ChunkCoordinates chunkcoordinates1 = block.getBedSpawnPosition(par0World, c.posX, c.posY, c.posZ, null);
             return chunkcoordinates1;
         }
         else
@@ -1614,10 +1913,13 @@
     {
         if (this.playerLocation != null)
         {
-            int i = this.worldObj.getBlockMetadata(this.playerLocation.posX, this.playerLocation.posY, this.playerLocation.posZ);
-            int j = BlockBed.getDirection(i);
-
-            switch (j)
+            int x = playerLocation.posX;
+            int y = playerLocation.posY;
+            int z = playerLocation.posZ;
+            Block block = Block.blocksList[worldObj.getBlockId(x, y, z)];
+            int i = (block == null ? 0 : block.getBedDirection(worldObj, x, y, z));
+
+            switch (i)
             {
                 case 0:
                     return 90.0F;
@@ -1683,14 +1985,40 @@
     /**
      * Returns the location of the bed the player will respawn at, or null if the player has not slept in a bed.
      */
+    @Deprecated
     public ChunkCoordinates getBedLocation()
     {
-        return this.spawnChunk;
-    }
-
+        return getBedLocation(this.dimension);
+    }
+
+    @Deprecated
     public boolean isSpawnForced()
     {
-        return this.spawnForced;
+        return isSpawnForced(this.dimension);
+    }
+
+    /**
+     * A dimension aware version of getBedLocation.
+     * @param dimension The dimension to get the bed spawn for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public ChunkCoordinates getBedLocation(int dimension) {
+        if (dimension == 0) return this.spawnChunk;
+        return this.spawnChunkMap.get(dimension);
+    }
+
+    /**
+     * A dimension aware version of isSpawnForced.
+     * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not.
+     * This just extends that to be dimension aware.
+     * @param dimension The dimension to get whether to check for a bed before spawning for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public boolean isSpawnForced(int dimension) {
+        if (dimension == 0) return this.spawnForced;
+        Boolean forced = this.spawnForcedMap.get(dimension);
+        if (forced == null) return false;
+        return forced;
     }
 
     /**
@@ -1698,18 +2026,49 @@
      */
     public void setSpawnChunk(ChunkCoordinates par1ChunkCoordinates, boolean par2)
     {
+        if (this.dimension != 0) {
+            setSpawnChunk(par1ChunkCoordinates, par2, this.dimension);
+            return;
+        }
         if (par1ChunkCoordinates != null)
         {
             this.spawnChunk = new ChunkCoordinates(par1ChunkCoordinates);
             this.spawnForced = par2;
+            this.spawnWorld = this.worldObj.worldInfo.getWorldName(); // CraftBukkit
         }
         else
         {
             this.spawnChunk = null;
             this.spawnForced = false;
-        }
-    }
-
+            this.spawnWorld = ""; // CraftBukkit
+        }
+    }
+    /**
+     * A dimension aware version of setSpawnChunk.
+     * This functions identically, but allows you to specify which dimension to affect, rather than affecting the player's current dimension.
+     * @param chunkCoordinates The spawn point to set as the player-specific spawn point for the dimension
+     * @param forced Whether or not the respawn code should check for a bed at this location (true means it won't check for a bed)
+     * @param dimension Which dimension to apply the player-specific respawn point to
+     */
+    public void setSpawnChunk(ChunkCoordinates chunkCoordinates, boolean forced, int dimension) {
+        if (dimension == 0) {
+            if (chunkCoordinates != null) {
+                this.spawnChunk = new ChunkCoordinates(chunkCoordinates);
+                this.spawnForced = forced;
+            } else {
+                this.spawnChunk = null;
+                this.spawnForced = false;
+            }
+            return;
+        }
+        if (chunkCoordinates != null) {
+            this.spawnChunkMap.put(dimension, new ChunkCoordinates(chunkCoordinates));
+            this.spawnForcedMap.put(dimension, forced);
+        } else {
+            this.spawnChunkMap.remove(dimension);
+            this.spawnForcedMap.remove(dimension);
+        }
+    }
     /**
      * Will trigger the specified trigger.
      */
@@ -1891,6 +2250,10 @@
 
             super.fall(par1);
         }
+        else
+        {
+            MinecraftForge.EVENT_BUS.post(new PlayerFlyableFallEvent(this, par1));
+        }
     }
 
     /**
@@ -1932,7 +2295,7 @@
         {
             if (par1ItemStack.getItem().requiresMultipleRenderPasses())
             {
-                return par1ItemStack.getItem().getIconFromDamageForRenderPass(par1ItemStack.getItemDamage(), par2);
+                return par1ItemStack.getItem().getIcon(par1ItemStack, par2);
             }
 
             if (this.itemInUse != null && par1ItemStack.itemID == Item.bow.itemID)
@@ -1954,6 +2317,7 @@
                     return Item.bow.getItemIconForUseDuration(0);
                 }
             }
+            icon = par1ItemStack.getItem().getIcon(par1ItemStack, par2, this, itemInUse, itemInUseCount);
         }
 
         return icon;
@@ -2175,7 +2539,17 @@
             this.setScore(par1EntityPlayer.getScore());
         }
 
+        this.spawnChunkMap = par1EntityPlayer.spawnChunkMap;
+        this.spawnForcedMap = par1EntityPlayer.spawnForcedMap;
         this.theInventoryEnderChest = par1EntityPlayer.theInventoryEnderChest;
+
+        //Copy over a section of the Entity Data from the old player.
+        //Allows mods to specify data that persists after players respawn.
+        NBTTagCompound old = par1EntityPlayer.getEntityData();
+        if (old.hasKey(PERSISTED_NBT_TAG))
+        {
+            getEntityData().setCompoundTag(PERSISTED_NBT_TAG, old.getCompoundTag(PERSISTED_NBT_TAG));
+        }
     }
 
     /**
@@ -2239,7 +2613,14 @@
      */
     public void setCurrentItemOrArmor(int par1, ItemStack par2ItemStack)
     {
-        this.inventory.armorInventory[par1] = par2ItemStack;
+        if (par1 == 0)
+        {
+            this.inventory.mainInventory[this.inventory.currentItem] = par2ItemStack;
+        }
+        else
+        {
+            this.inventory.armorInventory[par1 - 1] = par2ItemStack;
+        }
     }
 
     @SideOnly(Side.CLIENT)
