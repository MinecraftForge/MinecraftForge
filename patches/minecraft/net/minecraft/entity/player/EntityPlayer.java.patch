--- ../src_base/minecraft/net/minecraft/entity/player/EntityPlayer.java
+++ ../src_work/minecraft/net/minecraft/entity/player/EntityPlayer.java
@@ -5,8 +5,11 @@
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map.Entry;
+
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockBed;
 import net.minecraft.block.material.Material;
@@ -66,8 +69,23 @@
 import net.minecraft.world.World;
 import net.minecraft.world.chunk.IChunkProvider;
 
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.common.ISpecialArmor.ArmorProperties;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.ForgeEventFactory;
+import net.minecraftforge.event.entity.living.LivingHurtEvent;
+import net.minecraftforge.event.entity.player.AttackEntityEvent;
+import net.minecraftforge.event.entity.player.EntityInteractEvent;
+import net.minecraftforge.event.entity.player.PlayerDestroyItemEvent;
+import net.minecraftforge.event.entity.player.PlayerDropsEvent;
+import net.minecraftforge.event.entity.player.PlayerFlyableFallEvent;
+import net.minecraftforge.event.entity.player.PlayerSleepInBedEvent;
+
 public abstract class EntityPlayer extends EntityLiving implements ICommandSender
 {
+    public static final String PERSISTED_NBT_TAG = "PlayerPersisted";
+    public int maxHealth = 20;
+
     /** Inventory of the player */
     public InventoryPlayer inventory = new InventoryPlayer(this);
     private InventoryEnderChest theInventoryEnderChest = new InventoryEnderChest();
@@ -120,12 +138,12 @@
     /**
      * Holds the last coordinate to spawn based on last bed that the player sleep.
      */
-    private ChunkCoordinates spawnChunk;
+    private HashMap<Integer, ChunkCoordinates> spawnChunk = new HashMap<Integer, ChunkCoordinates>();
 
     /**
      * Whether this player's spawn point is forced, preventing execution of bed checks.
      */
-    private boolean spawnForced;
+    private HashMap<Integer, Boolean> spawnForced = new HashMap<Integer, Boolean>();
 
     /** Holds the coordinate of the player when enter a minecraft to ride. */
     private ChunkCoordinates startMinecartRidingCoordinate;
@@ -181,7 +199,7 @@
 
     public int getMaxHealth()
     {
-        return 20;
+        return maxHealth <= 0 ? 20 : maxHealth;
     }
 
     protected void entityInit()
@@ -268,6 +286,7 @@
 
             if (itemstack == this.itemInUse)
             {
+                itemInUse.getItem().onUsingItemTick(itemInUse, this, itemInUseCount);
                 if (this.itemInUseCount <= 25 && this.itemInUseCount % 4 == 0)
                 {
                     this.updateItemUse(itemstack, 5);
@@ -528,11 +547,11 @@
         this.cameraYaw = 0.0F;
         this.addMountedMovementStat(this.posX - d0, this.posY - d1, this.posZ - d2);
 
-        if (this.ridingEntity instanceof EntityPig)
+        if (this.ridingEntity instanceof EntityLiving && ((EntityLiving)ridingEntity).shouldRiderFaceForward(this))
         {
             this.rotationPitch = f1;
             this.rotationYaw = f;
-            this.renderYawOffset = ((EntityPig)this.ridingEntity).renderYawOffset;
+            this.renderYawOffset = ((EntityLiving)this.ridingEntity).renderYawOffset;
         }
     }
 
@@ -661,6 +680,9 @@
         this.setPosition(this.posX, this.posY, this.posZ);
         this.motionY = 0.10000000149011612D;
 
+        captureDrops = true;
+        capturedDrops.clear();
+
         if (this.username.equals("Notch"))
         {
             this.dropPlayerItemWithRandomChoice(new ItemStack(Item.appleRed, 1), true);
@@ -669,6 +691,20 @@
         if (!this.worldObj.getGameRules().getGameRuleBooleanValue("keepInventory"))
         {
             this.inventory.dropAllItems();
+        }
+
+        captureDrops = false;
+
+        if (!worldObj.isRemote)
+        {
+            PlayerDropsEvent event = new PlayerDropsEvent(this, par1DamageSource, capturedDrops, recentlyHit > 0);
+            if (!MinecraftForge.EVENT_BUS.post(event))
+            {
+                for (EntityItem item : capturedDrops)
+                {
+                    joinEntityItemWithWorld(item);
+                }
+            }
         }
 
         if (par1DamageSource != null)
@@ -719,7 +755,20 @@
      */
     public EntityItem dropOneItem(boolean par1)
     {
-        return this.dropPlayerItemWithRandomChoice(this.inventory.decrStackSize(this.inventory.currentItem, par1 && this.inventory.getCurrentItem() != null ? this.inventory.getCurrentItem().stackSize : 1), false);
+        ItemStack stack = inventory.getCurrentItem();
+
+        if (stack == null)
+        {
+            return null;
+        }
+
+        if (stack.getItem().onDroppedByPlayer(stack, this))
+        {
+            int count = par1 && this.inventory.getCurrentItem() != null ? this.inventory.getCurrentItem().stackSize : 1;
+            return ForgeHooks.onPlayerTossEvent(this, inventory.decrStackSize(inventory.currentItem, count));
+        }
+
+        return null;
     }
 
     /**
@@ -728,7 +777,7 @@
      */
     public EntityItem dropPlayerItem(ItemStack par1ItemStack)
     {
-        return this.dropPlayerItemWithRandomChoice(par1ItemStack, false);
+        return ForgeHooks.onPlayerTossEvent(this, par1ItemStack);
     }
 
     /**
@@ -780,15 +829,28 @@
      */
     public void joinEntityItemWithWorld(EntityItem par1EntityItem)
     {
+        if (captureDrops)
+        {
+            capturedDrops.add(par1EntityItem);
+            return;
+        }
         this.worldObj.spawnEntityInWorld(par1EntityItem);
     }
 
     /**
      * Returns how strong the player is against the specified block at this moment
-     */
+     * Deprecated in favor of the more sensitive version
+     */
+    @Deprecated
     public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2)
     {
-        float f = this.inventory.getStrVsBlock(par1Block);
+        return getCurrentPlayerStrVsBlock(par1Block, par2, 0);
+    }
+
+    public float getCurrentPlayerStrVsBlock(Block par1Block, boolean par2, int meta)
+    {
+        ItemStack stack = inventory.getCurrentItem();
+        float f = (stack == null ? 1.0F : stack.getItem().getStrVsBlock(stack, par1Block, meta));
 
         if (f > 1.0F)
         {
@@ -799,7 +861,9 @@
             {
                 float f1 = (float)(i * i + 1);
 
-                if (!itemstack.canHarvestBlock(par1Block) && f <= 1.0F)
+                boolean canHarvest = ForgeHooks.canToolHarvestBlock(par1Block, meta, itemstack);
+
+                if (!canHarvest && f <= 1.0F)
                 {
                     f += f1 * 0.08F;
                 }
@@ -830,7 +894,8 @@
             f /= 5.0F;
         }
 
-        return f;
+        f = ForgeEventFactory.getBreakSpeed(this, par1Block, meta, f);
+        return (f < 0 ? 0 : f);
     }
 
     /**
@@ -838,7 +903,7 @@
      */
     public boolean canHarvestBlock(Block par1Block)
     {
-        return this.inventory.canHarvestBlock(par1Block);
+        return ForgeEventFactory.doPlayerHarvestCheck(this, par1Block, inventory.canHarvestBlock(par1Block));
     }
 
     /**
@@ -857,6 +922,9 @@
         this.experienceTotal = par1NBTTagCompound.getInteger("XpTotal");
         this.setScore(par1NBTTagCompound.getInteger("Score"));
 
+        int tmp = par1NBTTagCompound.getInteger("MaxHealth");
+        maxHealth = (tmp <= 0 ? 20 : tmp);
+
         if (this.sleeping)
         {
             this.playerLocation = new ChunkCoordinates(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ));
@@ -865,8 +933,16 @@
 
         if (par1NBTTagCompound.hasKey("SpawnX") && par1NBTTagCompound.hasKey("SpawnY") && par1NBTTagCompound.hasKey("SpawnZ"))
         {
-            this.spawnChunk = new ChunkCoordinates(par1NBTTagCompound.getInteger("SpawnX"), par1NBTTagCompound.getInteger("SpawnY"), par1NBTTagCompound.getInteger("SpawnZ"));
-            this.spawnForced = par1NBTTagCompound.getBoolean("SpawnForced");
+            this.spawnChunk.put(0, new ChunkCoordinates(par1NBTTagCompound.getInteger("SpawnX"), par1NBTTagCompound.getInteger("SpawnY"), par1NBTTagCompound.getInteger("SpawnZ")));
+            this.spawnForced.put(0, par1NBTTagCompound.getBoolean("SpawnForced"));
+        }
+        NBTTagList spawnlist = null;
+        spawnlist = par1NBTTagCompound.getTagList("Spawns");
+        for (int i = 0; i < spawnlist.tagCount(); ++i) {
+            NBTTagCompound spawndata = (NBTTagCompound)spawnlist.tagAt(i);
+            int spawndim = spawndata.getInteger("Dim");
+            this.spawnChunk.put(spawndim, new ChunkCoordinates(spawndata.getInteger("SpawnX"), spawndata.getInteger("SpawnY"), spawndata.getInteger("SpawnZ")));
+            this.spawnForced.put(spawndim, spawndata.getBoolean("SpawnForced"));
         }
 
         this.foodStats.readNBT(par1NBTTagCompound);
@@ -893,14 +969,23 @@
         par1NBTTagCompound.setInteger("XpLevel", this.experienceLevel);
         par1NBTTagCompound.setInteger("XpTotal", this.experienceTotal);
         par1NBTTagCompound.setInteger("Score", this.getScore());
-
-        if (this.spawnChunk != null)
-        {
-            par1NBTTagCompound.setInteger("SpawnX", this.spawnChunk.posX);
-            par1NBTTagCompound.setInteger("SpawnY", this.spawnChunk.posY);
-            par1NBTTagCompound.setInteger("SpawnZ", this.spawnChunk.posZ);
-            par1NBTTagCompound.setBoolean("SpawnForced", this.spawnForced);
-        }
+        par1NBTTagCompound.setInteger("MaxHealth", maxHealth);
+
+        NBTTagList spawnlist = new NBTTagList();
+        for (Entry<Integer, ChunkCoordinates> entry : this.spawnChunk.entrySet()) {
+            NBTTagCompound spawndata = new NBTTagCompound();
+            ChunkCoordinates spawn = entry.getValue();
+            if (spawn == null) continue;
+            Boolean forced = spawnForced.get(entry.getKey());
+            if (forced == null) forced = false;
+            spawndata.setInteger("Dim", entry.getKey());
+            spawndata.setInteger("SpawnX", spawn.posX);
+            spawndata.setInteger("SpawnY", spawn.posY);
+            spawndata.setInteger("SpawnZ", spawn.posZ);
+            spawndata.setBoolean("SpawnForced", forced);
+            spawnlist.appendTag(spawndata);
+        }
+        par1NBTTagCompound.setTag("Spawns", spawnlist);
 
         this.foodStats.writeNBT(par1NBTTagCompound);
         this.capabilities.writeCapabilitiesToNBT(par1NBTTagCompound);
@@ -1096,12 +1181,22 @@
     {
         if (!this.isEntityInvulnerable())
         {
+            par2 = ForgeHooks.onLivingHurt(this, par1DamageSource, par2);
+            if (par2 <= 0)
+            {
+                return;
+            }
+
             if (!par1DamageSource.isUnblockable() && this.isBlocking())
             {
                 par2 = 1 + par2 >> 1;
             }
 
-            par2 = this.applyArmorCalculations(par1DamageSource, par2);
+            par2 = ArmorProperties.ApplyArmor(this, inventory.armorInventory, par1DamageSource, par2);
+            if (par2 <= 0)
+            {
+                return;
+            }
             par2 = this.applyPotionDamageCalculations(par1DamageSource, par2);
             this.addExhaustion(par1DamageSource.getHungerDamage());
             int j = this.getHealth();
@@ -1144,6 +1239,10 @@
 
     public boolean interactWith(Entity par1Entity)
     {
+        if (MinecraftForge.EVENT_BUS.post(new EntityInteractEvent(this, par1Entity)))
+        {
+            return false;
+        }
         if (par1Entity.interact(this))
         {
             return true;
@@ -1187,7 +1286,9 @@
      */
     public void destroyCurrentEquippedItem()
     {
+        ItemStack orig = getCurrentEquippedItem();
         this.inventory.setInventorySlotContents(this.inventory.currentItem, (ItemStack)null);
+        MinecraftForge.EVENT_BUS.post(new PlayerDestroyItemEvent(this, orig));
     }
 
     /**
@@ -1204,6 +1305,15 @@
      */
     public void attackTargetEntityWithCurrentItem(Entity par1Entity)
     {
+        if (MinecraftForge.EVENT_BUS.post(new AttackEntityEvent(this, par1Entity)))
+        {
+            return;
+        }
+        ItemStack stack = getCurrentEquippedItem();
+        if (stack != null && stack.getItem().onLeftClickEntity(stack, this, par1Entity))
+        {
+            return;
+        }
         if (par1Entity.canAttackWithItem())
         {
             if (!par1Entity.func_85031_j(this))
@@ -1378,6 +1488,12 @@
      */
     public EnumStatus sleepInBedAt(int par1, int par2, int par3)
     {
+        PlayerSleepInBedEvent event = new PlayerSleepInBedEvent(this, par1, par2, par3);
+        MinecraftForge.EVENT_BUS.post(event);
+        if (event.result != null)
+        {
+            return event.result;
+        }
         if (!this.worldObj.isRemote)
         {
             if (this.isPlayerSleeping() || !this.isEntityAlive())
@@ -1417,6 +1533,11 @@
         {
             int l = this.worldObj.getBlockMetadata(par1, par2, par3);
             int i1 = BlockBed.getDirection(l);
+            Block block = Block.blocksList[worldObj.getBlockId(par1, par2, par3)];
+            if (block != null)
+            {
+                i1 = block.getBedDirection(worldObj, par1, par2, par3);
+            }
             float f = 0.5F;
             float f1 = 0.5F;
 
@@ -1487,10 +1608,12 @@
         ChunkCoordinates chunkcoordinates = this.playerLocation;
         ChunkCoordinates chunkcoordinates1 = this.playerLocation;
 
-        if (chunkcoordinates != null && this.worldObj.getBlockId(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ) == Block.bed.blockID)
-        {
-            BlockBed.setBedOccupied(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, false);
-            chunkcoordinates1 = BlockBed.getNearestEmptyChunkCoordinates(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, 0);
+        Block block = (chunkcoordinates == null ? null : Block.blocksList[worldObj.getBlockId(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ)]);
+
+        if (chunkcoordinates != null && block != null && block.isBed(worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this))
+        {
+            block.setBedOccupied(this.worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this, false);
+            chunkcoordinates1 = block.getBedSpawnPosition(worldObj, chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ, this);
 
             if (chunkcoordinates1 == null)
             {
@@ -1527,7 +1650,9 @@
      */
     private boolean isInBed()
     {
-        return this.worldObj.getBlockId(this.playerLocation.posX, this.playerLocation.posY, this.playerLocation.posZ) == Block.bed.blockID;
+        ChunkCoordinates c = playerLocation;
+        int blockID = worldObj.getBlockId(c.posX, c.posY, c.posZ);
+        return Block.blocksList[blockID] != null && Block.blocksList[blockID].isBed(worldObj, c.posX, c.posY, c.posZ, this);
     }
 
     /**
@@ -1542,9 +1667,12 @@
         ichunkprovider.loadChunk(par1ChunkCoordinates.posX - 3 >> 4, par1ChunkCoordinates.posZ + 3 >> 4);
         ichunkprovider.loadChunk(par1ChunkCoordinates.posX + 3 >> 4, par1ChunkCoordinates.posZ + 3 >> 4);
 
-        if (par0World.getBlockId(par1ChunkCoordinates.posX, par1ChunkCoordinates.posY, par1ChunkCoordinates.posZ) == Block.bed.blockID)
-        {
-            ChunkCoordinates chunkcoordinates1 = BlockBed.getNearestEmptyChunkCoordinates(par0World, par1ChunkCoordinates.posX, par1ChunkCoordinates.posY, par1ChunkCoordinates.posZ, 0);
+        ChunkCoordinates c = par1ChunkCoordinates;
+        Block block = Block.blocksList[par0World.getBlockId(c.posX, c.posY, c.posZ)];
+
+        if (block != null && block.isBed(par0World, c.posX, c.posY, c.posZ, null))
+        {
+            ChunkCoordinates chunkcoordinates1 = block.getBedSpawnPosition(par0World, c.posX, c.posY, c.posZ, null);
             return chunkcoordinates1;
         }
         else
@@ -1566,10 +1694,13 @@
     {
         if (this.playerLocation != null)
         {
-            int i = this.worldObj.getBlockMetadata(this.playerLocation.posX, this.playerLocation.posY, this.playerLocation.posZ);
-            int j = BlockBed.getDirection(i);
-
-            switch (j)
+            int x = playerLocation.posX;
+            int y = playerLocation.posY;
+            int z = playerLocation.posZ;
+            Block block = Block.blocksList[worldObj.getBlockId(x, y, z)];
+            int i = (block == null ? 0 : block.getBedDirection(worldObj, x, y, z));
+
+            switch (i)
             {
                 case 0:
                     return 90.0F;
@@ -1635,14 +1766,38 @@
     /**
      * Returns the location of the bed the player will respawn at, or null if the player has not slept in a bed.
      */
+    @Deprecated
     public ChunkCoordinates getBedLocation()
     {
-        return this.spawnChunk;
-    }
-
+        return getBedLocation(this.dimension);
+    }
+
+    @Deprecated
     public boolean isSpawnForced()
     {
-        return this.spawnForced;
+        return isSpawnForced(this.dimension);
+    }
+
+    /**
+     * A dimension aware version of getBedLocation.
+     * @param dimension The dimension to get the bed spawn for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public ChunkCoordinates getBedLocation(int dimension) {
+        return this.spawnChunk.get(dimension);
+    }
+
+    /**
+     * A dimension aware version of isSpawnForced.
+     * Noramally isSpawnForced is used to determine if the respawn system should check for a bed or not.
+     * This just extends that to be dimension aware.
+     * @param dimension The dimension to get whether to check for a bed before spawning for
+     * @return The player specific spawn location for the dimension.  May be null.
+     */
+    public boolean isSpawnForced(int dimension) {
+        Boolean forced = this.spawnForced.get(dimension);
+        if (forced == null) return false;
+        return forced;
     }
 
     /**
@@ -1652,13 +1807,29 @@
     {
         if (par1ChunkCoordinates != null)
         {
-            this.spawnChunk = new ChunkCoordinates(par1ChunkCoordinates);
-            this.spawnForced = par2;
+            this.spawnChunk.put(this.dimension, new ChunkCoordinates(par1ChunkCoordinates));
+            this.spawnForced.put(this.dimension, par2);
         }
         else
         {
-            this.spawnChunk = null;
-            this.spawnForced = false;
+            this.spawnChunk.remove(this.dimension);
+            this.spawnForced.remove(this.dimension);
+        }
+    }
+    /**
+     * A dimension aware version of setSpawnChunk.
+     * This functions identically, but allows you to specify which dimension to affect, rather than affecting the player's current dimension.
+     * @param chunkCoordinates The spawn point to set as the player-specific spawn point for the dimension
+     * @param forced Whether or not the respawn code should check for a bed at this location (true means it won't check for a bed)
+     * @param dimension Which dimension to apply the player-specific respawn point to
+     */
+    public void setSpawnChunk(ChunkCoordinates chunkCoordinates, boolean forced, int dimension) {
+        if (chunkCoordinates != null) {
+            this.spawnChunk.put(dimension, new ChunkCoordinates(chunkCoordinates));
+            this.spawnForced.put(dimension, forced);
+        } else {
+            this.spawnChunk.remove(dimension);
+            this.spawnForced.remove(dimension);
         }
     }
 
@@ -1835,6 +2006,10 @@
 
             super.fall(par1);
         }
+        else
+        {
+            MinecraftForge.EVENT_BUS.post(new PlayerFlyableFallEvent(this, par1));
+        }
     }
 
     /**
@@ -1876,7 +2051,7 @@
         {
             if (par1ItemStack.getItem().requiresMultipleRenderPasses())
             {
-                return par1ItemStack.getItem().getIconFromDamageForRenderPass(par1ItemStack.getItemDamage(), par2);
+                return par1ItemStack.getItem().getIcon(par1ItemStack, par2);
             }
 
             if (this.itemInUse != null && par1ItemStack.itemID == Item.bow.itemID)
@@ -1898,6 +2073,7 @@
                     return Item.bow.getItemIconForUseDuration(0);
                 }
             }
+            icon = par1ItemStack.getItem().getIcon(par1ItemStack, par2, this, itemInUse, itemInUseCount);
         }
 
         return icon;
@@ -2136,7 +2312,17 @@
             this.setScore(par1EntityPlayer.getScore());
         }
 
+        this.spawnChunk = par1EntityPlayer.spawnChunk;
+        this.spawnForced = par1EntityPlayer.spawnForced;
         this.theInventoryEnderChest = par1EntityPlayer.theInventoryEnderChest;
+
+        //Copy over a section of the Entity Data from the old player.
+        //Allows mods to specify data that persists after players respawn.
+        NBTTagCompound old = par1EntityPlayer.getEntityData();
+        if (old.hasKey(PERSISTED_NBT_TAG))
+        {
+            getEntityData().setCompoundTag(PERSISTED_NBT_TAG, old.getCompoundTag(PERSISTED_NBT_TAG));
+        }
     }
 
     /**
@@ -2208,7 +2394,14 @@
      */
     public void setCurrentItemOrArmor(int par1, ItemStack par2ItemStack)
     {
-        this.inventory.armorInventory[par1] = par2ItemStack;
+        if (par1 == 0)
+        {
+            this.inventory.mainInventory[this.inventory.currentItem] = par2ItemStack;
+        }
+        else
+        {
+            this.inventory.armorInventory[par1 - 1] = par2ItemStack;
+        }
     }
 
     @SideOnly(Side.CLIENT)
