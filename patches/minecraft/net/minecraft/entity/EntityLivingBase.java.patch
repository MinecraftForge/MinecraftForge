--- ../src_base/minecraft/net/minecraft/entity/EntityLivingBase.java
+++ ../src_work/minecraft/net/minecraft/entity/EntityLivingBase.java
@@ -20,14 +20,18 @@
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.entity.monster.EntityZombie;
+import net.minecraft.entity.passive.EntityHorse;
+import net.minecraft.entity.passive.EntityPig;
 import net.minecraft.entity.passive.EntityWolf;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.projectile.EntityArrow;
+import net.minecraft.item.Item;
 import net.minecraft.item.ItemArmor;
 import net.minecraft.item.ItemStack;
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagFloat;
+import net.minecraft.nbt.NBTTagInt;
 import net.minecraft.nbt.NBTTagList;
 import net.minecraft.nbt.NBTTagShort;
 import net.minecraft.network.packet.Packet18Animation;
@@ -46,14 +50,22 @@
 import net.minecraft.util.Vec3;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
+import net.minecraftforge.common.ForgeHooks;
+// CraftBukkit start
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.entity.EntityDamageEvent;
+import org.bukkit.event.entity.EntityRegainHealthEvent;
+import net.minecraft.entity.player.EntityPlayerMP;
+// CraftBukkit end
 
 public abstract class EntityLivingBase extends Entity
 {
     private static final UUID sprintingSpeedBoostModifierUUID = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
     private static final AttributeModifier sprintingSpeedBoostModifier = (new AttributeModifier(sprintingSpeedBoostModifierUUID, "Sprinting speed boost", 0.30000001192092896D, 2)).setSaved(false);
     private BaseAttributeMap attributeMap;
-    private final CombatTracker _combatTracker = new CombatTracker(this);
-    private final HashMap activePotionsMap = new HashMap();
+    public CombatTracker _combatTracker = new CombatTracker(this); // CraftBukkit - private -> public, remove final
+    public final HashMap activePotionsMap = new HashMap(); // CraftBukkit - protected -> public
 
     /** The equipment this mob was previously wearing, used for syncing. */
     private final ItemStack[] previousEquipment = new ItemStack[5];
@@ -110,7 +122,7 @@
     public float jumpMovementFactor = 0.02F;
 
     /** The most recent player that has attacked this entity */
-    protected EntityPlayer attackingPlayer;
+    public EntityPlayer attackingPlayer; // CraftBukkit - protected -> public
 
     /**
      * Set to 60 when hit by the player or the player's wolf, then decrements. Used to determine whether the entity
@@ -137,7 +149,7 @@
     /**
      * Damage taken in the last hit. Mobs are resistant to damage less than this for a short time after taking damage.
      */
-    protected float lastDamage;
+    public float lastDamage; // CraftBukkit - protected -> public
 
     /** used to check whether entity is jumping. */
     protected boolean isJumping;
@@ -164,10 +176,10 @@
     protected double newRotationPitch;
 
     /** Whether the DataWatcher needs to be updated with the active potions */
-    private boolean potionsNeedUpdate = true;
+    public boolean potionsNeedUpdate = true; // CraftBukkit - private -> public
 
     /** is only being set, has no uses as of MC 1.1 */
-    private EntityLivingBase entityLivingToAttack;
+    public EntityLivingBase entityLivingToAttack; // CraftBukkit - private -> public
     private int revengeTimer;
     private EntityLivingBase lastAttacker;
 
@@ -183,12 +195,18 @@
     /** Number of ticks since last jump */
     private int jumpTicks;
     private float field_110151_bq;
+    // CraftBukkit start
+    public int expToDrop;
+    public int maxAirTicks = 300;
+    // CraftBukkit end
+    public boolean calledDeathEvent = false; // MCPC+
 
     public EntityLivingBase(World par1World)
     {
         super(par1World);
         this.applyEntityAttributes();
-        this.setHealth(this.getMaxHealth());
+        // CraftBukkit - setHealth(getMaxHealth()) inlined and simplified to skip the instanceof check for EntityPlayer, as getBukkitEntity() is not initialized in constructor
+        this.dataWatcher.updateObject(6, (float) this.getEntityAttribute(SharedMonsterAttributes.maxHealth).getAttributeValue());
         this.preventEntitySpawning = true;
         this.field_70770_ap = (float)(Math.random() + 1.0D) * 0.01F;
         this.setPosition(this.posX, this.posY, this.posZ);
@@ -305,14 +323,20 @@
 
             this.extinguish();
 
-            if (!this.worldObj.isRemote && this.isRiding() && this.ridingEntity instanceof EntityLivingBase)
+            if (!this.worldObj.isRemote && this.isRiding() && ridingEntity!=null && ridingEntity.shouldDismountInWater(this))
             {
                 this.mountEntity((Entity)null);
             }
         }
         else
         {
-            this.setAir(300);
+            // CraftBukkit start - Only set if needed to work around a DataWatcher inefficiency
+            if (this.getAir() != 300)
+            {
+                this.setAir(maxAirTicks);
+            }
+
+            // CraftBukkit end
         }
 
         this.prevCameraPitch = this.cameraPitch;
@@ -365,6 +389,22 @@
         this.worldObj.theProfiler.endSection();
     }
 
+    // CraftBukkit start
+    public int getExpReward()
+    {
+        int exp = this.getExperiencePoints(this.attackingPlayer);
+
+        if (!this.worldObj.isRemote && (this.recentlyHit > 0 || this.isPlayer()) && !this.isChild())
+        {
+            return exp;
+        }
+        else
+        {
+            return 0;
+        }
+    }
+    // CraftBukkit end
+
     /**
      * If Animal, checks if the age timer is negative
      */
@@ -380,22 +420,21 @@
     {
         ++this.deathTime;
 
-        if (this.deathTime == 20)
+        if (this.deathTime >= 20 && !this.isDead)   // CraftBukkit - (this.deathTicks == 20) -> (this.deathTicks >= 20 && !this.dead)
         {
             int i;
-
-            if (!this.worldObj.isRemote && (this.recentlyHit > 0 || this.isPlayer()) && !this.isChild() && this.worldObj.getGameRules().getGameRuleBooleanValue("doMobLoot"))
-            {
-                i = this.getExperiencePoints(this.attackingPlayer);
-
-                while (i > 0)
-                {
-                    int j = EntityXPOrb.getXPSplit(i);
-                    i -= j;
-                    this.worldObj.spawnEntityInWorld(new EntityXPOrb(this.worldObj, this.posX, this.posY, this.posZ, j));
-                }
-            }
-
+            // CraftBukkit start - Update getExpReward() above if the removed if() changes!
+            i = this.expToDrop;
+
+            while (i > 0)
+            {
+                int j = EntityXPOrb.getXPSplit(i);
+                i -= j;
+                this.worldObj.spawnEntityInWorld(new EntityXPOrb(this.worldObj, this.posX, this.posY, this.posZ, j));
+            }
+
+            this.expToDrop = 0;
+            // CraftBukkit end
             this.setDead();
 
             for (i = 0; i < 20; ++i)
@@ -452,6 +491,7 @@
     {
         this.entityLivingToAttack = par1EntityLivingBase;
         this.revengeTimer = this.ticksExisted;
+        ForgeHooks.onLivingSetAttackTarget(this, par1EntityLivingBase);
     }
 
     public EntityLivingBase getLastAttacker()
@@ -562,6 +602,23 @@
             }
         }
 
+        // CraftBukkit start
+        if (par1NBTTagCompound.hasKey("Bukkit.MaxHealth"))
+        {
+            NBTBase nbtbase = par1NBTTagCompound.getTag("Bukkit.MaxHealth");
+
+            if (nbtbase.getId() == 5)
+            {
+                this.getEntityAttribute(SharedMonsterAttributes.maxHealth).setAttribute((double)((NBTTagFloat) nbtbase).data);
+            }
+            else if (nbtbase.getId() == 3)
+            {
+                this.getEntityAttribute(SharedMonsterAttributes.maxHealth).setAttribute((double)((NBTTagInt) nbtbase).data);
+            }
+        }
+
+        // CraftBukkit end
+
         if (par1NBTTagCompound.hasKey("HealF"))
         {
             this.setHealth(par1NBTTagCompound.getFloat("HealF"));
@@ -691,12 +748,14 @@
 
     public boolean isPotionActive(int par1)
     {
-        return this.activePotionsMap.containsKey(Integer.valueOf(par1));
+        // CraftBukkit - Add size check for efficiency
+        return this.activePotionsMap.size() != 0 && this.activePotionsMap.containsKey(Integer.valueOf(par1));
     }
 
     public boolean isPotionActive(Potion par1Potion)
     {
-        return this.activePotionsMap.containsKey(Integer.valueOf(par1Potion.id));
+        // CraftBukkit - Add size check for efficiency
+        return this.activePotionsMap.size() != 0 && this.activePotionsMap.containsKey(Integer.valueOf(par1Potion.id));
     }
 
     /**
@@ -750,10 +809,8 @@
         return this.getCreatureAttribute() == EnumCreatureAttribute.UNDEAD;
     }
 
-    @SideOnly(Side.CLIENT)
-
-    /**
-     * Remove the speified potion effect from this entity.
+    /**
+     * Remove the specified potion effect from this entity.
      */
     public void removePotionEffectClient(int par1)
     {
@@ -804,26 +861,69 @@
         }
     }
 
+    // CraftBukkit start - Delegate so we can handle providing a reason for health being regained
     /**
      * Heal living entity (param: amount of half-hearts)
      */
     public void heal(float par1)
     {
+        heal(par1, EntityRegainHealthEvent.RegainReason.CUSTOM);
+    }
+
+    public void heal(float f, EntityRegainHealthEvent.RegainReason regainReason)
+    {
         float f1 = this.getHealth();
 
         if (f1 > 0.0F)
         {
-            this.setHealth(f1 + par1);
+            EntityRegainHealthEvent event = new EntityRegainHealthEvent(this.getBukkitEntity(), f, regainReason);
+            this.worldObj.getServer().getPluginManager().callEvent(event);
+
+            if (!event.isCancelled())
+            {
+                this.setHealth((float)(this.getHealth() + event.getAmount()));
+            }
         }
     }
 
     public final float getHealth()
     {
+        // CraftBukkit start - Use unscaled health
+        if (this instanceof EntityPlayerMP)
+        {
+            return (float)((EntityPlayerMP) this).getBukkitEntity().getHealth();
+        }
+
+        // CraftBukkit end
         return this.dataWatcher.getWatchableObjectFloat(6);
     }
 
     public void setHealth(float par1)
     {
+        // CraftBukkit start - Handle scaled health
+        if (this instanceof EntityPlayerMP)
+        {
+            org.bukkit.craftbukkit.entity.CraftPlayer player = ((EntityPlayerMP) this).getBukkitEntity();
+
+            // Squeeze
+            if (par1 < 0.0F)
+            {
+                player.setRealHealth(0.0D);
+            }
+            else if (par1 > player.getMaxHealth())
+            {
+                player.setRealHealth(player.getMaxHealth());
+            }
+            else
+            {
+                player.setRealHealth(par1);
+            }
+
+            this.dataWatcher.updateObject(6, Float.valueOf(player.getScaledHealth()));
+            return;
+        }
+
+        // CraftBukkit end
         this.dataWatcher.updateObject(6, Float.valueOf(MathHelper.clamp_float(par1, 0.0F, this.getMaxHealth())));
     }
 
@@ -832,6 +932,7 @@
      */
     public boolean attackEntityFrom(DamageSource par1DamageSource, float par2)
     {
+        if (ForgeHooks.onLivingAttack(this, par1DamageSource, par2)) return false;
         if (this.isEntityInvulnerable())
         {
             return false;
@@ -862,6 +963,20 @@
 
                 this.limbSwingAmount = 1.5F;
                 boolean flag = true;
+                // CraftBukkit start
+                EntityDamageEvent event = CraftEventFactory.handleEntityDamageEvent(this, par1DamageSource, par2);
+
+                if (event != null)
+                {
+                    if (event.isCancelled())
+                    {
+                        return false;
+                    }
+
+                    par2 = (float) event.getDamage();
+                }
+
+                // CraftBukkit end
 
                 if ((float)this.hurtResistantTime > (float)this.maxHurtResistantTime / 2.0F)
                 {
@@ -982,6 +1097,7 @@
      */
     public void onDeath(DamageSource par1DamageSource)
     {
+        if (ForgeHooks.onLivingDeath(this, par1DamageSource)) return;
         Entity entity = par1DamageSource.getEntity();
         EntityLivingBase entitylivingbase = this.func_94060_bK();
 
@@ -1006,24 +1122,54 @@
                 i = EnchantmentHelper.getLootingModifier((EntityLivingBase)entity);
             }
 
+            captureDrops = true;
+            capturedDrops.clear();
+            int j = 0;
+
             if (!this.isChild() && this.worldObj.getGameRules().getGameRuleBooleanValue("doMobLoot"))
             {
                 this.dropFewItems(this.recentlyHit > 0, i);
                 this.dropEquipment(this.recentlyHit > 0, i);
 
-                if (this.recentlyHit > 0)
-                {
-                    int j = this.rand.nextInt(200) - i;
+                /*if (this.recentlyHit > 0)   // CraftBukkit - move rare item drop call to dropDeathLoot
+                {
+                    j = this.rand.nextInt(200) - i;
 
                     if (j < 5)
                     {
                         this.dropRareDrop(j <= 0 ? 1 : 0);
                     }
+                }*/
+            }
+            else // CraftBukkit
+            {
+                CraftEventFactory.callEntityDeathEvent(this); // CraftBukkit
+            }
+            
+            captureDrops = false;
+
+            if (!ForgeHooks.onLivingDrops(this, par1DamageSource, capturedDrops, i, recentlyHit > 0, j))
+            {
+                // MCPC+ start - if death event has not been called, capture drops for plugins then fire event
+                if (!this.calledDeathEvent)
+                {
+                    java.util.List<org.bukkit.inventory.ItemStack> loot = new java.util.ArrayList<org.bukkit.inventory.ItemStack>();
+                    for (EntityItem item : capturedDrops)
+                    {
+                        loot.add(CraftItemStack.asCraftMirror(item.getEntityItem()));
+                    }
+                    CraftEventFactory.callEntityDeathEvent(this, loot);
+                }
+                // MCPC+ end
+                for (EntityItem item : capturedDrops)
+                {
+                    worldObj.spawnEntityInWorld(item);
                 }
             }
         }
 
         this.worldObj.setEntityState(this, (byte)3);
+        this.calledDeathEvent = false;
     }
 
     /**
@@ -1071,7 +1217,12 @@
         return "damage.hit";
     }
 
-    protected void dropRareDrop(int par1) {}
+    // CraftBukkit start - Change return type to ItemStack
+    protected ItemStack dropRareDrop(int i)
+    {
+        return null;
+    }
+    // CraftBukkit end
 
     /**
      * Drop 0-2 items of this living's type. @param par1 - Whether this entity has recently been hit by a player. @param
@@ -1088,7 +1239,7 @@
         int j = MathHelper.floor_double(this.boundingBox.minY);
         int k = MathHelper.floor_double(this.posZ);
         int l = this.worldObj.getBlockId(i, j, k);
-        return l == Block.ladder.blockID || l == Block.vine.blockID;
+        return ForgeHooks.isLivingOnLadder(Block.blocksList[l], worldObj, i, j, k, this);
     }
 
     /**
@@ -1104,10 +1255,32 @@
      */
     protected void fall(float par1)
     {
+        par1 = ForgeHooks.onLivingFall(this, par1);
+        if (par1 <= 0) return;
         super.fall(par1);
         PotionEffect potioneffect = this.getActivePotionEffect(Potion.jump);
         float f1 = potioneffect != null ? (float)(potioneffect.getAmplifier() + 1) : 0.0F;
-        int i = MathHelper.ceiling_float_int(par1 - 3.0F - f1);
+        // CraftBukkit start
+        float i = MathHelper.ceiling_float_int(par1 - 3.0F - f1);
+
+        if (i > 0)
+        {
+            EntityDamageEvent event = CraftEventFactory.callEntityDamageEvent(null, this, EntityDamageEvent.DamageCause.FALL, i);
+
+            if (event.isCancelled())
+            {
+                return;
+            }
+
+            i = (float) event.getDamage();
+
+            if (i > 0)
+            {
+                this.getBukkitEntity().setLastDamageCause(event);
+            }
+        }
+
+        // CraftBukkit end
 
         if (i > 0)
         {
@@ -1237,6 +1410,8 @@
     {
         if (!this.isEntityInvulnerable())
         {
+            par2 = ForgeHooks.onLivingHurt(this, par1DamageSource, par2);
+            if (par2 <= 0) return;
             par2 = this.applyArmorCalculations(par1DamageSource, par2);
             par2 = this.applyPotionDamageCalculations(par1DamageSource, par2);
             float f1 = par2;
@@ -1298,6 +1473,17 @@
      */
     public void swingItem()
     {
+        ItemStack stack = this.getHeldItem();
+
+        if (stack != null && stack.getItem() != null)
+        {
+            Item item = stack.getItem();
+            if (item.onEntitySwing(this, stack))
+            {
+                return;
+            }
+        }
+
         if (!this.isSwingInProgress || this.swingProgressInt >= this.getArmSwingAnimationEnd() / 2 || this.swingProgressInt < 0)
         {
             this.swingProgressInt = -1;
@@ -1535,6 +1721,7 @@
         }
 
         this.isAirBorne = true;
+        ForgeHooks.onLivingJump(this);
     }
 
     /**
@@ -1739,6 +1926,11 @@
      */
     public void onUpdate()
     {
+        if (ForgeHooks.onLivingUpdate(this))
+        {
+            return;
+        }
+
         super.onUpdate();
 
         if (!this.worldObj.isRemote)
@@ -1797,7 +1989,7 @@
         {
             f3 = 1.0F;
             f2 = (float)Math.sqrt((double)f) * 3.0F;
-            f1 = (float)Math.atan2(d1, d0) * 180.0F / (float)Math.PI - 90.0F;
+            f1 = (float) org.bukkit.craftbukkit.TrigMath.atan2(d1, d0) * 180.0F / (float)Math.PI - 90.0F;  // CraftBukkit - Math -> TrigMath
         }
 
         if (this.swingProgress > 0.0F)
@@ -2009,11 +2201,20 @@
     {
         List list = this.worldObj.getEntitiesWithinAABBExcludingEntity(this, this.boundingBox.expand(0.20000000298023224D, 0.0D, 0.20000000298023224D));
 
-        if (list != null && !list.isEmpty())
+        if (this.canBePushed() && list != null && !list.isEmpty()) // Spigot: Add this.canBePushed() condition
         {
             for (int i = 0; i < list.size(); ++i)
             {
                 Entity entity = (Entity)list.get(i);
+
+                // TODO better check now?
+                // CraftBukkit start - Only handle mob (non-player) collisions every other tick
+                if (entity instanceof EntityLivingBase && !(this instanceof EntityPlayerMP) && this.ticksExisted % 2 == 0)
+                {
+                    continue;
+                }
+
+                // CraftBukkit end
 
                 if (entity.canBePushed())
                 {
@@ -2277,4 +2478,42 @@
     {
         return this.getTeam() != null ? this.getTeam().isSameTeam(par1Team) : false;
     }
+
+    /***
+     * Removes all potion effects that have curativeItem as a curative item for its effect
+     * @param curativeItem The itemstack we are using to cure potion effects
+     */
+    public void curePotionEffects(ItemStack curativeItem)
+    {
+        Iterator<Integer> potionKey = activePotionsMap.keySet().iterator();
+
+        if (worldObj.isRemote)
+        {
+            return;
+        }
+
+        while (potionKey.hasNext())
+        {
+            Integer key = potionKey.next();
+            PotionEffect effect = (PotionEffect)activePotionsMap.get(key);
+
+            if (effect.isCurativeItem(curativeItem))
+            {
+                potionKey.remove();
+                onFinishedPotionEffect(effect);
+            }
+        }
+    }
+
+    /**
+     * Returns true if the entity's rider (EntityPlayer) should face forward when mounted.
+     * currently only used in vanilla code by pigs.
+     *
+     * @param player The player who is riding the entity.
+     * @return If the player should orient the same direction as this entity.
+     */
+    public boolean shouldRiderFaceForward(EntityPlayer player)
+    {
+        return this instanceof EntityPig;
+    }
 }
