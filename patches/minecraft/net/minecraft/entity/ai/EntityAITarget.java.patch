--- ../src_base/minecraft/net/minecraft/entity/ai/EntityAITarget.java
+++ ../src_work/minecraft/net/minecraft/entity/ai/EntityAITarget.java
@@ -10,6 +10,10 @@
 import net.minecraft.pathfinding.PathPoint;
 import net.minecraft.util.MathHelper;
 import org.apache.commons.lang3.StringUtils;
+// CraftBukkit start
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.event.entity.EntityTargetEvent;
+// CraftBukkit end
 
 public abstract class EntityAITarget extends EntityAIBase
 {
@@ -20,9 +24,21 @@
      * If true, EntityAI targets must be able to be seen (cannot be blocked by walls) to be suitable targets.
      */
     protected boolean shouldCheckSight;
-    private boolean field_75303_a;
-    private int field_75301_b;
-    private int field_75302_c;
+
+    /**
+     * When true, only entities that can be reached with minimal effort will be targetted.
+     */
+    private boolean nearbyOnly;
+
+    /**
+     * When nearbyOnly is true: 0 -> No target, but OK to search; 1 -> Nearby target found; 2 -> Target too far.
+     */
+    private int targetSearchStatus;
+
+    /**
+     * When nearbyOnly is true, this throttles target searching to avoid excessive pathfinding.
+     */
+    private int targetSearchDelay;
     private int field_75298_g;
 
     public EntityAITarget(EntityCreature par1EntityCreature, boolean par2)
@@ -34,7 +50,7 @@
     {
         this.taskOwner = par1EntityCreature;
         this.shouldCheckSight = par2;
-        this.field_75303_a = par3;
+        this.nearbyOnly = par3;
     }
 
     /**
@@ -54,7 +70,7 @@
         }
         else
         {
-            double d0 = this.func_111175_f();
+            double d0 = this.getTargetDistance();
 
             if (this.taskOwner.getDistanceSqToEntity(entitylivingbase) > d0 * d0)
             {
@@ -79,10 +95,10 @@
         }
     }
 
-    protected double func_111175_f()
-    {
-        AttributeInstance attributeinstance = this.taskOwner.func_110148_a(SharedMonsterAttributes.field_111265_b);
-        return attributeinstance == null ? 16.0D : attributeinstance.func_111126_e();
+    protected double getTargetDistance()
+    {
+        AttributeInstance attributeinstance = this.taskOwner.getEntityAttribute(SharedMonsterAttributes.followRange);
+        return attributeinstance == null ? 16.0D : attributeinstance.getAttributeValue();
     }
 
     /**
@@ -90,8 +106,8 @@
      */
     public void startExecuting()
     {
-        this.field_75301_b = 0;
-        this.field_75302_c = 0;
+        this.targetSearchStatus = 0;
+        this.targetSearchDelay = 0;
         this.field_75298_g = 0;
     }
 
@@ -153,32 +169,79 @@
             }
             else
             {
-                if (this.field_75303_a)
-                {
-                    if (--this.field_75302_c <= 0)
-                    {
-                        this.field_75301_b = 0;
-                    }
-
-                    if (this.field_75301_b == 0)
-                    {
-                        this.field_75301_b = this.func_75295_a(par1EntityLivingBase) ? 1 : 2;
-                    }
-
-                    if (this.field_75301_b == 2)
+                if (this.nearbyOnly)
+                {
+                    if (--this.targetSearchDelay <= 0)
+                    {
+                        this.targetSearchStatus = 0;
+                    }
+
+                    if (this.targetSearchStatus == 0)
+                    {
+                        this.targetSearchStatus = this.canEasilyReach(par1EntityLivingBase) ? 1 : 2;
+                    }
+
+                    if (this.targetSearchStatus == 2)
                     {
                         return false;
                     }
                 }
 
+                // CraftBukkit start - Check all the different target goals for the reason, default to RANDOM_TARGET
+                EntityTargetEvent.TargetReason reason = EntityTargetEvent.TargetReason.RANDOM_TARGET;
+
+                if (this instanceof EntityAIDefendVillage)
+                {
+                    reason = EntityTargetEvent.TargetReason.DEFEND_VILLAGE;
+                }
+                else if (this instanceof EntityAIHurtByTarget)
+                {
+                    reason = EntityTargetEvent.TargetReason.TARGET_ATTACKED_ENTITY;
+                }
+                else if (this instanceof EntityAINearestAttackableTarget)
+                {
+                    if (par1EntityLivingBase instanceof EntityPlayer)
+                    {
+                        reason = EntityTargetEvent.TargetReason.CLOSEST_PLAYER;
+                    }
+                }
+                else if (this instanceof EntityAIOwnerHurtByTarget)
+                {
+                    reason = EntityTargetEvent.TargetReason.TARGET_ATTACKED_OWNER;
+                }
+                else if (this instanceof EntityAIOwnerHurtTarget)
+                {
+                    reason = EntityTargetEvent.TargetReason.OWNER_ATTACKED_TARGET;
+                }
+
+                org.bukkit.event.entity.EntityTargetLivingEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTargetLivingEvent(this.taskOwner, par1EntityLivingBase, reason);
+
+                if (event.isCancelled() || event.getTarget() == null)
+                {
+                    this.taskOwner.setAttackTarget(null);
+                    return false;
+                }
+                else if (par1EntityLivingBase.getBukkitEntity() != event.getTarget())
+                {
+                    this.taskOwner.setAttackTarget((EntityLivingBase)((CraftEntity) event.getTarget()).getHandle());
+                }
+
+                if (this.taskOwner instanceof EntityCreature)
+                {
+                    ((EntityCreature) this.taskOwner).entityToAttack = ((CraftEntity) event.getTarget()).getHandle();
+                }
+                // CraftBukkit end
                 return true;
             }
         }
     }
 
-    private boolean func_75295_a(EntityLivingBase par1EntityLivingBase)
-    {
-        this.field_75302_c = 10 + this.taskOwner.getRNG().nextInt(5);
+    /**
+     * Checks to see if this entity can find a short path to the given target.
+     */
+    private boolean canEasilyReach(EntityLivingBase par1EntityLivingBase)
+    {
+        this.targetSearchDelay = 10 + this.taskOwner.getRNG().nextInt(5);
         PathEntity pathentity = this.taskOwner.getNavigator().getPathToEntityLiving(par1EntityLivingBase);
 
         if (pathentity == null)
