--- a/net/minecraft/resources/RegistryReadOps.java
+++ b/net/minecraft/resources/RegistryReadOps.java
@@ -47,7 +_,8 @@
    public final RegistryReadOps<JsonElement> f_135638_;
 
    public static <T> RegistryReadOps<T> m_179866_(DynamicOps<T> p_179867_, ResourceManager p_179868_, RegistryAccess p_179869_) {
-      return m_179870_(p_179867_, RegistryReadOps.ResourceAccess.m_135714_(p_179868_), p_179869_);
+      // FORGE -- when importing datapacks into dynamic registries, ensure imports aren't done redundantly (needed for the dynamic registries loaded hook)
+      return net.minecraftforge.common.ForgeHooks.importDatapacksIntoDynamicRegistries(p_179867_, p_179868_, p_179869_);
    }
 
    public static <T> RegistryReadOps<T> m_179870_(DynamicOps<T> p_179871_, RegistryReadOps.ResourceAccess p_179872_, RegistryAccess p_179873_) {
@@ -65,11 +_,17 @@
    }
 
    private RegistryReadOps(DynamicOps<T> p_179862_, RegistryReadOps.ResourceAccess p_179863_, RegistryAccess p_179864_, IdentityHashMap<ResourceKey<? extends Registry<?>>, RegistryReadOps.ReadCache<?>> p_179865_) {
+      this(p_179862_, p_179863_, p_179864_, p_179865_, new java.util.HashMap<>()); // FORGE -- we need a separate constructor that accepts a map of cached ops types for the dynamic registries loaded hook 
+   }
+   /** @deprecated forge internal field -- cache RegistryReadOps so we can provide the correct one in the dynamic registries loaded hook **/
+   @Deprecated public final Map<DynamicOps<?>, RegistryReadOps<?>> extraOps;
+   public RegistryReadOps(DynamicOps<T> p_179862_, RegistryReadOps.ResourceAccess p_179863_, RegistryAccess p_179864_, IdentityHashMap<ResourceKey<? extends Registry<?>>, RegistryReadOps.ReadCache<?>> p_179865_, final Map<DynamicOps<?>, RegistryReadOps<?>> extraOps) {
       super(p_179862_);
       this.f_135635_ = p_179863_;
       this.f_179860_ = p_179864_;
       this.f_135637_ = p_179865_;
-      this.f_135638_ = p_179862_ == JsonOps.INSTANCE ? (RegistryReadOps<JsonElement>)this : new RegistryReadOps<>(JsonOps.INSTANCE, p_179863_, p_179864_, p_179865_);
+      this.f_135638_ = p_179862_ == JsonOps.INSTANCE ? (RegistryReadOps<JsonElement>)this : new RegistryReadOps<>(JsonOps.INSTANCE, p_179863_, p_179864_, p_179865_, extraOps); // forge -- ensure related RegistryReadOps share the same extraOps map
+      this.extraOps = extraOps;
    }
 
    protected <E> DataResult<Pair<Supplier<E>, T>> m_135677_(T p_135678_, ResourceKey<? extends Registry<E>> p_135679_, Codec<E> p_135680_, boolean p_135681_) {
@@ -220,6 +_,7 @@
                         try {
                            JsonParser jsonparser = new JsonParser();
                            JsonElement jsonelement = jsonparser.parse(reader);
+                           if (jsonelement != null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_179899_.m_135782_().toString());
                            optional = Optional.of(p_179900_.parse(p_179897_, jsonelement).map((p_135730_) -> {
                               return Pair.of(p_135730_, OptionalInt.empty());
                            }));
@@ -290,6 +_,7 @@
 
          public <E> Optional<DataResult<Pair<E, OptionalInt>>> m_142701_(DynamicOps<JsonElement> p_179902_, ResourceKey<? extends Registry<E>> p_179903_, ResourceKey<E> p_179904_, Decoder<E> p_179905_) {
             JsonElement jsonelement = this.f_135736_.get(p_179904_);
+            if (jsonelement != null) jsonelement.getAsJsonObject().addProperty("forge:registry_name", p_179904_.m_135782_().toString());
             return jsonelement == null ? Optional.of(DataResult.error("Unknown element: " + p_179904_)) : Optional.of(p_179905_.parse(p_179902_, jsonelement).setLifecycle(this.f_135738_.get(p_179904_)).map((p_135756_) -> {
                return Pair.of(p_135756_, OptionalInt.of(this.f_135737_.getInt(p_179904_)));
             }));
