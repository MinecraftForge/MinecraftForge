--- ../src_base/minecraft/net/minecraft/world/World.java
+++ ../src_work/minecraft/net/minecraft/world/World.java
@@ -1,7 +1,10 @@
 package net.minecraft.world;
 
+import cpw.mods.fml.common.FMLLog;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
+
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -10,6 +13,7 @@
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.Callable;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockFluid;
 import net.minecraft.block.BlockHalfSlab;
@@ -22,11 +26,21 @@
 import net.minecraft.crash.CrashReportCategory;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityMinecart;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityHorse;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.item.ItemBlock;
 import net.minecraft.item.ItemStack;
 import net.minecraft.logging.ILogAgent;
-import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.pathfinding.PathEntity;
 import net.minecraft.pathfinding.PathFinder;
 import net.minecraft.profiler.Profiler;
@@ -49,27 +63,75 @@
 import net.minecraft.world.biome.WorldChunkManager;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.storage.ISaveHandler;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
 
+import com.google.common.collect.ImmutableSetMultimap;
+
+import net.minecraftforge.client.ForgeHooksClient;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.ForgeChunkManager;
+import net.minecraftforge.common.ForgeChunkManager.Ticket;
+import net.minecraftforge.common.ForgeDummyContainer;
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.common.ForgeDirection;
+import net.minecraftforge.common.WorldSpecificSaveHandler;
+import net.minecraftforge.event.entity.EntityEvent;
+import net.minecraftforge.event.entity.EntityJoinWorldEvent;
+import net.minecraftforge.event.world.WorldEvent;
+import net.minecraftforge.event.entity.PlaySoundAtEntityEvent;
+import net.minecraft.entity.EnumCreatureType;
+// CraftBukkit start
+import net.minecraft.entity.item.EntityXPOrb;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.event.weather.WeatherChangeEvent;
+import org.bukkit.event.weather.ThunderChangeEvent;
+// CraftBukkit end
+// MCPC+ start
+import net.minecraft.nbt.NBTTagCompound;
+import za.co.mcportcentral.MCPCConfig;
+import za.co.mcportcentral.MCPCHooks;
+import za.co.mcportcentral.MCPCWorldConfig;
+import za.co.mcportcentral.entity.CraftFakePlayer;
+// MCPC+ end
+
 public abstract class World implements IBlockAccess
 {
     /**
+     * Used in the getEntitiesWithinAABB functions to expand the search area for entities.
+     * Modders should change this variable to a higher value if it is less then the radius
+     * of one of there entities.
+     */
+    public static double MAX_ENTITY_RADIUS = 2.0D;
+
+    public final MapStorage perWorldStorage;
+
+    /**
      * boolean; if true updates scheduled by scheduleBlockUpdate happen immediately
      */
     public boolean scheduledUpdatesAreImmediate;
 
     /** A list of all Entities in all currently-loaded chunks */
     public List loadedEntityList = new ArrayList();
-    protected List unloadedEntityList = new ArrayList();
+    public List unloadedEntityList = new ArrayList(); // MCPC+ public for reporting purposes
 
     /** A list of all TileEntities in all currently-loaded chunks */
-    public List loadedTileEntityList = new ArrayList();
+    public List loadedTileEntityList = new ArrayList(); // CraftBukkit - ArrayList -> HashSet // MCPC+ - keep vanilla for mod compatibility
     private List addedTileEntityList = new ArrayList();
 
     /** Entities marked for removal. */
-    private List entityRemoval = new ArrayList();
+    public List entityRemoval = new ArrayList(); // MCPC+ public for reporting purposes
 
     /** Array list of players in the world. */
     public List playerEntities = new ArrayList();
@@ -102,6 +164,7 @@
      * unused.
      */
     public int lastLightningBolt;
+    public boolean callingPlaceEvent = false; // CraftBukkit
 
     /** Option > Difficulty setting (0 - 3) */
     public int difficultySetting;
@@ -110,17 +173,17 @@
     public Random rand = new Random();
 
     /** The WorldProvider instance that World uses. */
-    public final WorldProvider provider;
+    public WorldProvider provider; // CraftBukkit - remove final
     protected List worldAccesses = new ArrayList();
 
     /** Handles chunk operations and caching */
-    protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider; // CraftBukkit - protected -> public
     protected final ISaveHandler saveHandler;
 
     /**
      * holds information about a world (size on disk, time, spawn point, seed, ...)
      */
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo; // CraftBukkit - protected -> public
 
     /** Boolean that is set to true when trying to find a spawn point */
     public boolean findingSpawnPoint;
@@ -132,21 +195,26 @@
     /** The world-local pool of vectors */
     private final Vec3Pool vecPool = new Vec3Pool(300, 2000);
     private final Calendar theCalendar = Calendar.getInstance();
-    protected Scoreboard worldScoreboard = new Scoreboard();
+    public Scoreboard worldScoreboard = new Scoreboard(); // CraftBukkit - protected -> public
 
     /** The log agent for this world. */
     private final ILogAgent worldLogAgent;
     private ArrayList collidingBoundingBoxes = new ArrayList();
     private boolean scanningTileEntities;
+    // CraftBukkit start - public, longhashset
 
     /** indicates if enemies are spawned or not */
-    protected boolean spawnHostileMobs = true;
+    public boolean spawnHostileMobs = true;
 
     /** A flag indicating whether we should spawn peaceful mobs. */
-    protected boolean spawnPeacefulMobs = true;
+    public boolean spawnPeacefulMobs = true;
 
     /** Positions to update */
-    public Set activeChunkSet = new HashSet();
+    protected gnu.trove.map.hash.TLongShortHashMap activeChunkSet_CB; // Spigot
+    public Set activeChunkSet = new HashSet(); // vanilla compatibility
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    // CraftBukkit end
 
     /** number of ticks until the next random ambients play */
     private int ambientTickCountdown;
@@ -161,12 +229,59 @@
 
     /** This is set to true for client worlds, and false for server worlds. */
     public boolean isRemote;
+    // MCPC+ start - block place
+    /** These hit coords are set by ItemBlock.onItemUse and are only used during a forge block place event in canPlaceEntityOnSide */
+    public float curPlacedItemHitX = 0;
+    public float curPlacedItemHitY = 0;
+    public float curPlacedItemHitZ = 0;
+    // MCPC+ end
+
+    // MCPC+ start - preload world crash report classes to fix NCDFE masking StackOverflow/memory error, see #721
+    private static boolean preloadedCrashClasses = false;
+    {
+        if (!preloadedCrashClasses)
+        {
+            // generate a temporary crash report
+            Throwable throwable = new Throwable();
+            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Block being updated");
+
+            // loads all the required classes - including net.minecraft.crash.CallableBlockType (package private)
+            crashreportcategory.addCrashSectionCallable("Source block type", (Callable)(new CallableLvl1(this, 0)));
+            CrashReportCategory.addBlockCrashInfo(crashreportcategory, 0, 0, 0, 0, -1);
+
+            preloadedCrashClasses = true;
+        }
+    }
+    // MCPC+ end
+    // Spigot start
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ((((long)x) & 0xFFFF0000L) << 16) | ((((long)x) & 0x0000FFFFL) << 0);
+        k |= ((((long)z) & 0xFFFF0000L) << 32) | ((((long)z) & 0x0000FFFFL) << 16);
+        return k;
+    }
+    public static int keyToX(long k)
+    {
+        return (int)(((k >> 16) & 0xFFFF0000) | (k & 0x0000FFFF));
+    }
+    public static int keyToZ(long k)
+    {
+        return (int)(((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
+    }
+    // Spigot end
 
     /**
      * Gets the biome for a given set of x/z coordinates
      */
     public BiomeGenBase getBiomeGenForCoords(int par1, int par2)
     {
+        return provider.getBiomeGenForCoords(par1, par2);
+    }
+
+    public BiomeGenBase getBiomeGenForCoordsBody(int par1, int par2)
+    {
         if (this.blockExists(par1, 0, par2))
         {
             Chunk chunk = this.getChunkFromBlockCoords(par1, par2);
@@ -184,6 +299,39 @@
     {
         return this.provider.worldChunkMgr;
     }
+
+    // CraftBukkit start
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+    Chunk lastChunkAccessed;
+    int lastXAccessed = Integer.MIN_VALUE;
+    int lastZAccessed = Integer.MIN_VALUE;
+    final Object chunkLock = new Object();
+    private byte chunkTickRadius; // Spigot
+    public org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+    public za.co.mcportcentral.MCPCWorldConfig mcpcConfig; // MCPC+
+    public SpigotTimings.WorldTimingsHandler timings; // Spigot
+
+    public CraftWorld getWorld()
+    {
+        return this.world;
+    }
+
+    public CraftServer getServer()
+    {
+        return (CraftServer) Bukkit.getServer();
+    }
+    
+    // MCPC+ start
+    public void setupConfigs(String name)
+    {
+        if (this.timings == null) this.timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( name ); // Spigot
+        this.mcpcConfig = new za.co.mcportcentral.MCPCWorldConfig( name ); // MCPC+
+    }
+    // MCPC+ end
 
     @SideOnly(Side.CLIENT)
     public World(ISaveHandler par1ISaveHandler, String par2Str, WorldProvider par3WorldProvider, WorldSettings par4WorldSettings, Profiler par5Profiler, ILogAgent par6ILogAgent)
@@ -194,8 +342,18 @@
         this.theProfiler = par5Profiler;
         this.worldInfo = new WorldInfo(par4WorldSettings, par2Str);
         this.provider = par3WorldProvider;
-        this.mapStorage = new MapStorage(par1ISaveHandler);
+        perWorldStorage = new MapStorage((ISaveHandler)null);
         this.worldLogAgent = par6ILogAgent;
+        // MCPC+ start
+        this.world = null;
+        setupConfigs(par2Str);
+        // MCPC+ end
+    }
+    
+    // Broken up so that the WorldClient gets the chance to set the mapstorage object before the dimension initializes
+    @SideOnly(Side.CLIENT)
+    protected void finishSetup()
+    {
         VillageCollection villagecollection = (VillageCollection)this.mapStorage.loadData(VillageCollection.class, "villages");
 
         if (villagecollection == null)
@@ -208,20 +366,177 @@
             this.villageCollectionObj = villagecollection;
             this.villageCollectionObj.func_82566_a(this);
         }
-
-        par3WorldProvider.registerWorld(this);
+        // Guarantee the dimension ID was not reset by the provider
+        int providerDim = this.provider.dimensionId;
+        this.provider.registerWorld(this);
+        this.provider.dimensionId = providerDim;
         this.chunkProvider = this.createChunkProvider();
         this.calculateInitialSkylight();
         this.calculateInitialWeather();
     }
 
-    public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
-    {
+    // Changed signature
+    public World(ISaveHandler idatamanager, String s, WorldSettings worldsettings, WorldProvider worldprovider, Profiler profiler, ILogAgent ilogagent, ChunkGenerator gen, org.bukkit.World.Environment env)
+    {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( s ); // Spigot
+        this.mcpcConfig = new za.co.mcportcentral.MCPCWorldConfig( s ); // MCPC+;
+        this.generator = gen;
+        this.worldInfo = idatamanager.loadWorldInfo(); // Spigot
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        this.chunkTickRadius = (byte)((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7); // CraftBukkit - don't tick chunks we don't load for player
+        // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
+        this.activeChunkSet_CB = new gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
+        this.activeChunkSet_CB.setAutoCompactionFactor( 0 );
+        // Spigot end
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int[32768];
+        this.isRemote = false;
+        this.saveHandler = idatamanager;
+        this.theProfiler = profiler;
+        // MCPC+ start - add config setting for keep spawn loaded globally and per world
+        boolean defaultKeepLoaded = MinecraftServer.configuration.getBoolean("world-settings.default.keep-spawn-loaded", true);
+        this.keepSpawnInMemory = MinecraftServer.configuration.getBoolean("world-settings." + s + ".keep-spawn-loaded", defaultKeepLoaded);
+        // MCPC+ end
+        
+        // MCPC+ start
+        // Provides a solution for different worlds getting different copies of the same data, potentially rewriting the data or causing race conditions/stale data
+        // Buildcraft has suffered from the issue this fixes.  If you load the same data from two different worlds they can get two different copies of the same object, thus the last saved gets final say.
+        if (DimensionManager.getWorld(0) != null) // if overworld has loaded, use its mapstorage
+        {
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        }
+        else // if we are loading overworld, create a new mapstorage
+        {
+            this.mapStorage = new MapStorage(idatamanager);
+        }
+        // MCPC+ end
+        this.worldLogAgent = ilogagent;
+        // this.worldInfo = idatamanager.loadWorldInfo(); // Spigot - Moved up
+
+        if (worldprovider != null)
+        {
+            this.provider = worldprovider;
+        }
+        else if (this.worldInfo != null && this.worldInfo.getDimension() != 0)
+        {
+            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getDimension());
+        }
+        else
+        {
+            this.provider = WorldProvider.getProviderForDimension(0);
+        }
+
+        if (this.worldInfo == null)
+        {
+            this.worldInfo = new WorldInfo(worldsettings, s);
+            this.worldInfo.setDimension(this.provider.dimensionId); // MCPC+ - Save dimension to level.dat
+        }
+        else
+        {
+            this.worldInfo.setWorldName(s);
+            // MCPC+ start - Use saved dimension from level.dat. Fixes issues with MultiVerse
+            if (this.worldInfo.getDimension() != 0)
+                this.provider.dimensionId = this.worldInfo.getDimension();
+            else
+            {
+                this.worldInfo.setDimension(this.provider.dimensionId);
+            }
+            // MCPC+ end
+        }
+
+        // MCPC+ start - Guarantee provider dimension is not reset. This is required for mods that rely on the provider ID to match the client dimension. Without this, IC2 will send the wrong ID to clients.
+        int providerId = this.provider.dimensionId;
+        this.provider.registerWorld(this);
+        this.provider.dimensionId = providerId;
+        // MCPC+ end
+        this.chunkProvider = this.createChunkProvider();
+        // MCPC+ start - add Forge
+        if (this instanceof WorldServer)
+        {
+            this.perWorldStorage = new MapStorage(new WorldSpecificSaveHandler((WorldServer)this, idatamanager));
+        }
+        else
+        {
+            this.perWorldStorage = new MapStorage((ISaveHandler)null);
+        }
+        // MCPC+ end
+
+        if (!this.worldInfo.isInitialized())
+        {
+            try
+            {
+                this.initialize(worldsettings);
+            }
+            catch (Throwable throwable)
+            {
+                CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception initializing level");
+
+                try
+                {
+                    this.addWorldInfoToCrashReport(crashreport);
+                }
+                catch (Throwable throwable1)
+                {
+                    ;
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            this.worldInfo.setServerInitialized(true);
+        }
+        //this.provider.dimensionId = providerId; // MCPC+ - Fix for TerrainControl injecting their own WorldProvider
+
+        VillageCollection villagecollection = (VillageCollection)perWorldStorage.loadData(VillageCollection.class, "villages");
+
+        if (villagecollection == null)
+        {
+            this.villageCollectionObj = new VillageCollection(this);
+            this.perWorldStorage.setData("villages", this.villageCollectionObj);
+        }
+        else
+        {
+            this.villageCollectionObj = villagecollection;
+            this.villageCollectionObj.func_82566_a(this);
+        }
+
+        this.calculateInitialSkylight();
+        this.calculateInitialWeather();
+        this.getServer().addWorld(this.world); // CraftBukkit
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
+    }
+    
+    public World(ISaveHandler par1ISaveHandler, String par2Str, WorldSettings par3WorldSettings, WorldProvider par4WorldProvider, Profiler par5Profiler, ILogAgent par6ILogAgent)
+    {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( par2Str ); // Spigot
+        this.mcpcConfig = new za.co.mcportcentral.MCPCWorldConfig( par2Str ); // MCPC+
+        this.world = null; // CraftWorld not used
+        this.ambientTickCountdown = this.rand.nextInt(12000);
+        this.lightUpdateBlockList = new int[32768];
+        this.isRemote = false;
         this.saveHandler = par1ISaveHandler;
         this.theProfiler = par5Profiler;
-        this.mapStorage = new MapStorage(par1ISaveHandler);
+        // MCPC+ start - add config setting for keep spawn loaded globally and per world
+        boolean defaultKeepLoaded = MinecraftServer.configuration.getBoolean("world-settings.default.keep-spawn-loaded", true);
+        this.keepSpawnInMemory = MinecraftServer.configuration.getBoolean("world-settings." + par2Str + ".keep-spawn-loaded", defaultKeepLoaded);
+        // MCPC+ end
+
+        // MCPC+ start
+        // Provides a solution for different worlds getting different copies of the same data, potentially rewriting the data or causing race conditions/stale data
+        // Buildcraft has suffered from the issue this fixes.  If you load the same data from two different worlds they can get two different copies of the same object, thus the last saved gets final say.
+        if (DimensionManager.getWorld(0) != null) // if overworld has loaded, use its mapstorage
+        {
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        }
+        else // if we are loading overworld, create a new mapstorage
+        {
+            this.mapStorage = new MapStorage(par1ISaveHandler);
+        }
+        // MCPC+ end
         this.worldLogAgent = par6ILogAgent;
         this.worldInfo = par1ISaveHandler.loadWorldInfo();
 
@@ -229,9 +544,9 @@
         {
             this.provider = par4WorldProvider;
         }
-        else if (this.worldInfo != null && this.worldInfo.getVanillaDimension() != 0)
-        {
-            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getVanillaDimension());
+        else if (this.worldInfo != null && this.worldInfo.getDimension() != 0)
+        {
+            this.provider = WorldProvider.getProviderForDimension(this.worldInfo.getDimension());
         }
         else
         {
@@ -249,6 +564,14 @@
 
         this.provider.registerWorld(this);
         this.chunkProvider = this.createChunkProvider();
+        if (this instanceof WorldServer)
+        {
+            this.perWorldStorage = new MapStorage(new WorldSpecificSaveHandler((WorldServer)this, par1ISaveHandler));
+        }
+        else
+        {
+            this.perWorldStorage = new MapStorage((ISaveHandler)null);
+        }
 
         if (!this.worldInfo.isInitialized())
         {
@@ -275,12 +598,12 @@
             this.worldInfo.setServerInitialized(true);
         }
 
-        VillageCollection villagecollection = (VillageCollection)this.mapStorage.loadData(VillageCollection.class, "villages");
+        VillageCollection villagecollection = (VillageCollection)perWorldStorage.loadData(VillageCollection.class, "villages");
 
         if (villagecollection == null)
         {
             this.villageCollectionObj = new VillageCollection(this);
-            this.mapStorage.setData("villages", this.villageCollectionObj);
+            this.perWorldStorage.setData("villages", this.villageCollectionObj);
         }
         else
         {
@@ -290,6 +613,22 @@
 
         this.calculateInitialSkylight();
         this.calculateInitialWeather();
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot
+    }
+    // MCPC+ end    
+
+    private static MapStorage s_mapStorage;
+    private static ISaveHandler s_savehandler;
+    //Provides a solution for different worlds getting different copies of the same data, potentially rewriting the data or causing race conditions/stale data
+    //Buildcraft has suffered from the issue this fixes.  If you load the same data from two different worlds they can get two different copies of the same object, thus the last saved gets final say.
+    private MapStorage getMapStorage(ISaveHandler savehandler)
+    {
+        if (s_savehandler != savehandler || s_mapStorage == null)
+        {
+            s_mapStorage = new MapStorage(savehandler);
+            s_savehandler = savehandler;
+        }
+        return s_mapStorage;
     }
 
     /**
@@ -373,7 +712,8 @@
      */
     public boolean isAirBlock(int par1, int par2, int par3)
     {
-        return this.getBlockId(par1, par2, par3) == 0;
+        int id = getBlockId(par1, par2, par3);
+        return id == 0 || Block.blocksList[id] == null || Block.blocksList[id].isAirBlock(this, par1, par2, par3);
     }
 
     /**
@@ -382,7 +722,8 @@
     public boolean blockHasTileEntity(int par1, int par2, int par3)
     {
         int l = this.getBlockId(par1, par2, par3);
-        return Block.blocksList[l] != null && Block.blocksList[l].hasTileEntity();
+        int meta = this.getBlockMetadata(par1, par2, par3);
+        return Block.blocksList[l] != null && Block.blocksList[l].hasTileEntity(meta);
     }
 
     /**
@@ -426,7 +767,8 @@
             {
                 for (int l1 = par3; l1 <= par6; ++l1)
                 {
-                    if (!this.chunkExists(k1, l1))
+                    // CraftBukkit - check unload queue too so we don't leak a chunk
+                    if (!this.chunkExists(k1, l1) || ((WorldServer) this).theChunkProviderServer.chunksToUnload.contains(k1, l1))
                     {
                         return false;
                     }
@@ -444,7 +786,7 @@
     /**
      * Returns whether a chunk exists at chunk coordinates x, y
      */
-    protected boolean chunkExists(int par1, int par2)
+    public boolean chunkExists(int par1, int par2) // MCPC+ - protected -> public for repackaging
     {
         return this.chunkProvider.chunkExists(par1, par2);
     }
@@ -457,13 +799,28 @@
         return this.getChunkFromChunkCoords(par1 >> 4, par2 >> 4);
     }
 
+    // CraftBukkit start
+
     /**
      * Returns back a chunk looked up by chunk coordinates Args: x, y
      */
     public Chunk getChunkFromChunkCoords(int par1, int par2)
     {
-        return this.chunkProvider.provideChunk(par1, par2);
-    }
+        // Spigot start - Alternate, sync-free-but-safe chunk reference cache
+        //synchronized (this.chunkLock) {
+        Chunk result = this.lastChunkAccessed; // Exploit fact that read is atomic
+
+        if (result == null || result.xPosition != par1 || result.zPosition != par2)
+        {
+            result = this.chunkProvider.provideChunk(par1, par2);
+            this.lastChunkAccessed = result; // Exploit fact that write is atomic
+        }
+
+        //}
+        // Spigot end
+        return result;
+    }
+    // CraftBukkit end
 
     /**
      * Sets the block ID and metadata at a given location. Args: X, Y, Z, new block ID, new metadata, flags. Flag 1 will
@@ -525,13 +882,76 @@
         }
     }
 
+    // MCPC+ start - new helper method for adding mod events
+
+    public boolean trySetBlockAndMetadata(int x, int y, int z, int blockID, int metadata, int flags, String username, boolean doLogin) // original name
+    {
+        return trySetBlock(x, y, z, blockID, metadata, flags, username, doLogin);
+    }
+
+    /**
+     * Attempt to set a block in the world, sending required events and cancelling if necessary.
+     * @param x
+     * @param y
+     * @param z
+     * @param blockID
+     * @param metadata
+     * @param flags
+     * @param username A real player's username (possibly offline) or fake player name enclosed in [brackets]
+     * @param doLogin If true, sends join events for fake players (should be configurable in the mod)
+     * @return true if successful, false if denied. Mods MUST not continue if denied.
+     */
+    public boolean trySetBlock(int x, int y, int z, int blockID, int metadata, int flags, String username, boolean doLogin)
+    {
+        int oldBlockID = this.getBlockId(x, y, z);
+        int oldMetadata = this.getBlockMetadata(x, y, z);
+
+        if (blockID == oldBlockID && metadata == oldMetadata) {
+            // no change
+            return false;
+        }
+
+        org.bukkit.entity.Player player = CraftFakePlayer.getPossiblyRealPlayerBukkitEntity(this, username, doLogin);
+
+        if (blockID == 0)
+        {
+            // Block break - modeled after ItemInWorldManager#tryHarvestBlock
+            org.bukkit.block.Block block = this.getWorld().getBlockAt(x, y, z);
+            org.bukkit.event.block.BlockBreakEvent event = new org.bukkit.event.block.BlockBreakEvent(block, player);
+
+            this.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled())
+            {
+                return false;
+            }
+            return setBlock(x, y, z, blockID, metadata, flags);
+        }
+        else
+        {
+            // Block place - delegate to ItemBlock#processBlockPlace
+            int clickedX = x, clickedY = y, clickedZ = z;
+            ItemStack itemstack = null;
+
+            return ItemBlock.processBlockPlace(this,
+                    ((org.bukkit.craftbukkit.entity.CraftPlayer)player).getHandle(),
+                    itemstack,
+                    x, y, z,
+                    blockID,
+                    metadata,
+                    clickedX, clickedY, clickedZ);
+        }
+    }
+    // MCPC+ end
+
+
     /**
      * Returns the block's material.
      */
     public Material getBlockMaterial(int par1, int par2, int par3)
     {
         int l = this.getBlockId(par1, par2, par3);
-        return l == 0 ? Material.air : Block.blocksList[l].blockMaterial;
+        return l == 0 || Block.blocksList[l] == null ? Material.air : Block.blocksList[l].blockMaterial; // MCPC+
     }
 
     /**
@@ -778,6 +1198,21 @@
             {
                 try
                 {
+                    // CraftBukkit start
+                    CraftWorld world = ((WorldServer) this).getWorld();
+
+                    if (world != null)
+                    {
+                        BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(par1, par2, par3), par4);
+                        this.getServer().getPluginManager().callEvent(event);
+
+                        if (event.isCancelled())
+                        {
+                            return;
+                        }
+                    }
+
+                    // CraftBukkit end
                     block.onNeighborBlockChange(this, par1, par2, par3, par4);
                 }
                 catch (Throwable throwable)
@@ -1157,7 +1592,7 @@
      */
     public boolean isDaytime()
     {
-        return this.skylightSubtracted < 4;
+        return provider.isDaytime();
     }
 
     /**
@@ -1192,7 +1627,7 @@
                 int l1 = this.getBlockMetadata(l, i1, j1);
                 Block block = Block.blocksList[k1];
 
-                if ((!par4 || block == null || block.getCollisionBoundingBoxFromPool(this, l, i1, j1) != null) && k1 > 0 && block.canCollideCheck(l1, par3))
+                if (block != null && (!par4 || block == null || block.getCollisionBoundingBoxFromPool(this, l, i1, j1) != null) && k1 > 0 && block.canCollideCheck(l1, par3))
                 {
                     MovingObjectPosition movingobjectposition = block.collisionRayTrace(this, l, i1, j1, par1Vec3, par2Vec3);
 
@@ -1368,9 +1803,12 @@
 
                         if (movingobjectposition1 != null)
                         {
+                            vec32.myVec3LocalPool.release(vec32); // CraftBukkit
                             return movingobjectposition1;
                         }
                     }
+
+                    vec32.myVec3LocalPool.release(vec32); // CraftBukkit
                 }
 
                 return null;
@@ -1392,6 +1830,12 @@
      */
     public void playSoundAtEntity(Entity par1Entity, String par2Str, float par3, float par4)
     {
+        PlaySoundAtEntityEvent event = new PlaySoundAtEntityEvent(par1Entity, par2Str, par3, par4);
+        if (MinecraftForge.EVENT_BUS.post(event))
+        {
+            return;
+        }
+        par2Str = event.name;
         if (par1Entity != null && par2Str != null)
         {
             for (int i = 0; i < this.worldAccesses.size(); ++i)
@@ -1406,6 +1850,12 @@
      */
     public void playSoundToNearExcept(EntityPlayer par1EntityPlayer, String par2Str, float par3, float par4)
     {
+        PlaySoundAtEntityEvent event = new PlaySoundAtEntityEvent(par1EntityPlayer, par2Str, par3, par4);
+        if (MinecraftForge.EVENT_BUS.post(event))
+        {
+            return;
+        }
+        par2Str = event.name;
         if (par1EntityPlayer != null && par2Str != null)
         {
             for (int i = 0; i < this.worldAccesses.size(); ++i)
@@ -1467,36 +1917,120 @@
         return true;
     }
 
+    // CraftBukkit start - Used for entities other than creatures
+
     /**
      * Called to place all entities as part of a world
      */
     public boolean spawnEntityInWorld(Entity par1Entity)
     {
-        int i = MathHelper.floor_double(par1Entity.posX / 16.0D);
-        int j = MathHelper.floor_double(par1Entity.posZ / 16.0D);
-        boolean flag = par1Entity.forceSpawn;
-
-        if (par1Entity instanceof EntityPlayer)
+        return this.addEntity(par1Entity, SpawnReason.DEFAULT); // Set reason as DEFAULT
+    }
+
+    public boolean addEntity(Entity entity, SpawnReason spawnReason)   // Changed signature, added SpawnReason
+    {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread)
+        {
+            throw new IllegalStateException("Asynchronous entity add!");    // Spigot
+        }
+        // MCPC+ start - do not drop any items during a place event. Fixes dupes in mods such as Flans
+        if (entity == null || (entity instanceof EntityItem && this.callingPlaceEvent))
+        {
+            return false;
+        }
+        // MCPC+ end
+
+        int i = MathHelper.floor_double(entity.posX / 16.0D);
+        int j = MathHelper.floor_double(entity.posZ / 16.0D);
+        boolean flag = entity.forceSpawn;
+
+        if (entity instanceof EntityPlayer)
         {
             flag = true;
         }
+        
+        // CraftBukkit start
+        org.bukkit.event.Cancellable event = null;
+
+        if (entity instanceof EntityLivingBase && !(entity instanceof EntityPlayerMP))
+        {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterMob || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMob || entity instanceof EntityGhast || entity instanceof EntitySlime;
+
+            if (spawnReason != SpawnReason.CUSTOM)
+            {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs)
+                {
+                    entity.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLivingBase) entity, spawnReason);
+        }
+        else if (entity instanceof EntityItem)
+        {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        }
+        else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile)
+        {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        }
+        // Spigot start
+        else if (entity instanceof EntityXPOrb)
+        {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = this.spigotConfig.expMerge;
+            if (radius > 0)
+            {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.boundingBox.expand(radius, radius, radius));
+                for (Entity e : entities)
+                {
+                    if (e instanceof EntityXPOrb)
+                    {
+                        EntityXPOrb loopItem = (EntityXPOrb) e;
+                        if (!loopItem.isDead)
+                        {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.isDead))
+        {
+            entity.isDead = true;
+            return false;
+        }
+
+        // CraftBukkit end
 
         if (!flag && !this.chunkExists(i, j))
         {
+            entity.isDead = true; // CraftBukkit
             return false;
         }
         else
         {
-            if (par1Entity instanceof EntityPlayer)
-            {
-                EntityPlayer entityplayer = (EntityPlayer)par1Entity;
+            if (entity instanceof EntityPlayer)
+            {
+                EntityPlayer entityplayer = (EntityPlayer) entity;
                 this.playerEntities.add(entityplayer);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            this.getChunkFromChunkCoords(i, j).addEntity(par1Entity);
-            this.loadedEntityList.add(par1Entity);
-            this.onEntityAdded(par1Entity);
+            if (MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(entity, this)) && !flag)
+            {
+                return false;
+            }
+
+            this.getChunkFromChunkCoords(i, j).addEntity(entity);
+            this.loadedEntityList.add(entity);
+            this.onEntityAdded(entity);
+            za.co.mcportcentral.MCPCHooks.logEntitySpawn(this, entity, spawnReason);
             return true;
         }
     }
@@ -1507,6 +2041,7 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityCreate(par1Entity);
         }
+        par1Entity.valid = true; // CraftBukkit
     }
 
     public void onEntityRemoved(Entity par1Entity)
@@ -1515,6 +2050,7 @@
         {
             ((IWorldAccess)this.worldAccesses.get(i)).onEntityDestroy(par1Entity);
         }
+        par1Entity.valid = false; // CraftBukkit
     }
 
     /**
@@ -1546,6 +2082,10 @@
      */
     public void removePlayerEntityDangerously(Entity par1Entity)
     {
+        if (Thread.currentThread() != MinecraftServer.getServer().primaryThread)
+        {
+            throw new IllegalStateException("Asynchronous entity remove!");    // Spigot
+        }
         par1Entity.setDead();
 
         if (par1Entity instanceof EntityPlayer)
@@ -1574,12 +2114,22 @@
         this.worldAccesses.add(par1IWorldAccess);
     }
 
+    public Entity lastBoundingBoxEntity;
+    public ChunkCoordinates lastBoundingBoxCoords;
+    public int lastBoundingBoxEntityCount;
+    public long totalBoundingBoxTime;
+    public long totalBoundingBoxCalls;
+    public long lastBoundingBoxTime;
+
+    
     /**
      * Returns a list of bounding boxes that collide with aabb excluding the passed in entity's collision. Args: entity,
      * aabb
      */
     public List getCollidingBoundingBoxes(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
     {
+        long time = System.currentTimeMillis();
+        lastBoundingBoxEntity = par1Entity;
         this.collidingBoundingBoxes.clear();
         int i = MathHelper.floor_double(par2AxisAlignedBB.minX);
         int j = MathHelper.floor_double(par2AxisAlignedBB.maxX + 1.0D);
@@ -1588,7 +2138,55 @@
         int i1 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
         int j1 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
 
-        for (int k1 = i; k1 < j; ++k1)
+        if (MCPCHooks.checkBoundingBoxSize(par1Entity, par2AxisAlignedBB)) return new ArrayList(); // Removing misbehaved entities
+
+        // Spigot start
+        int ystart = ((k - 1) < 0) ? 0 : (k - 1);
+
+        for (int chunkx = (i >> 4); chunkx <= ((j - 1) >> 4); chunkx++)
+        {
+            int cx = chunkx << 4;
+
+            for (int chunkz = (i1 >> 4); chunkz <= ((j1 - 1) >> 4); chunkz++)
+            {
+                if (!this.chunkExists(chunkx, chunkz))
+                {
+                    continue;
+                }
+
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkFromChunkCoords(chunkx, chunkz);
+                // Compute ranges within chunk
+                int xstart = (i < cx) ? cx : i;
+                int xend = (j < (cx + 16)) ? j : (cx + 16);
+                int zstart = (i1 < cz) ? cz : i1;
+                int zend = (j1 < (cz + 16)) ? j1 : (cz + 16);
+
+                // Loop through blocks within chunk
+                for (int x = xstart; x < xend; x++)
+                {
+                    for (int z = zstart; z < zend; z++)
+                    {
+                        for (int y = ystart; y < l; y++)
+                        {
+                            int blkid = chunk.getBlockID(x - cx, y, z - cz);
+
+                            if (blkid > 0)
+                            {
+                                Block block = Block.blocksList[blkid];
+
+                                if (block != null)
+                                {
+                                    block.addCollisionBoxesToList(this, x, y, z, par2AxisAlignedBB, this.collidingBoundingBoxes, par1Entity);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        /*for (int k1 = i; k1 < j; ++k1)
         {
             for (int l1 = i1; l1 < j1; ++l1)
             {
@@ -1596,6 +2194,7 @@
                 {
                     for (int i2 = k - 1; i2 < l; ++i2)
                     {
+                        lastBoundingBoxCoords = new ChunkCoordinates(k1, i2, l1);
                         Block block = Block.blocksList[this.getBlockId(k1, i2, l1)];
 
                         if (block != null)
@@ -1605,11 +2204,14 @@
                     }
                 }
             }
-        }
+        }*/// Spigot end
 
         double d0 = 0.25D;
         List list = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(d0, d0, d0));
 
+        lastBoundingBoxEntityCount = list.size();
+        za.co.mcportcentral.MCPCHooks.logEntitySize(this, par1Entity, list); // MCPC+ add logging for entity collisions
+
         for (int j2 = 0; j2 < list.size(); ++j2)
         {
             AxisAlignedBB axisalignedbb1 = ((Entity)list.get(j2)).getBoundingBox();
@@ -1626,7 +2228,10 @@
                 this.collidingBoundingBoxes.add(axisalignedbb1);
             }
         }
-
+        lastBoundingBoxTime = System.currentTimeMillis() - time;
+        totalBoundingBoxTime += lastBoundingBoxTime;
+        totalBoundingBoxCalls++;
+        
         return this.collidingBoundingBoxes;
     }
 
@@ -1733,6 +2338,12 @@
      */
     public Vec3 getSkyColor(Entity par1Entity, float par2)
     {
+        return provider.getSkyColor(par1Entity, par2);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3 getSkyColorBody(Entity par1Entity, float par2)
+    {
         float f1 = this.getCelestialAngle(par2);
         float f2 = MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 
@@ -1745,15 +2356,15 @@
         {
             f2 = 1.0F;
         }
-
+        
         int i = MathHelper.floor_double(par1Entity.posX);
         int j = MathHelper.floor_double(par1Entity.posZ);
-        BiomeGenBase biomegenbase = this.getBiomeGenForCoords(i, j);
-        float f3 = biomegenbase.getFloatTemperature();
-        int k = biomegenbase.getSkyColorByTemp(f3);
-        float f4 = (float)(k >> 16 & 255) / 255.0F;
-        float f5 = (float)(k >> 8 & 255) / 255.0F;
-        float f6 = (float)(k & 255) / 255.0F;
+        
+        int multiplier = ForgeHooksClient.getSkyBlendColour(this, i, j);
+
+        float f4 = (float)(multiplier >> 16 & 255) / 255.0F;
+        float f5 = (float)(multiplier >> 8 & 255) / 255.0F;
+        float f6 = (float)(multiplier & 255) / 255.0F;
         f4 *= f2;
         f5 *= f2;
         f6 *= f2;
@@ -1833,6 +2444,12 @@
     @SideOnly(Side.CLIENT)
     public Vec3 getCloudColour(float par1)
     {
+        return provider.drawClouds(par1);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3 drawCloudsBody(float par1)
+    {
         float f1 = this.getCelestialAngle(par1);
         float f2 = MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.5F;
 
@@ -1904,6 +2521,8 @@
     public int getTopSolidOrLiquidBlock(int par1, int par2)
     {
         Chunk chunk = this.getChunkFromBlockCoords(par1, par2);
+        int x = par1;
+        int z = par2;
         int k = chunk.getTopFilledSegment() + 15;
         par1 &= 15;
 
@@ -1911,7 +2530,7 @@
         {
             int l = chunk.getBlockID(par1, k, par2);
 
-            if (l != 0 && Block.blocksList[l].blockMaterial.blocksMovement() && Block.blocksList[l].blockMaterial != Material.leaves)
+            if (l != 0 && Block.blocksList[l].blockMaterial.blocksMovement() && Block.blocksList[l].blockMaterial != Material.leaves && !Block.blocksList[l].isBlockFoliage(this, x, k, z))
             {
                 return k + 1;
             }
@@ -1926,6 +2545,12 @@
      * How bright are stars in the sky
      */
     public float getStarBrightness(float par1)
+    {
+        return provider.getStarBrightness(par1);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public float getStarBrightnessBody(float par1)
     {
         float f1 = this.getCelestialAngle(par1);
         float f2 = 1.0F - (MathHelper.cos(f1 * (float)Math.PI * 2.0F) * 2.0F + 0.25F);
@@ -1966,10 +2591,30 @@
         Entity entity;
         CrashReport crashreport;
         CrashReportCategory crashreportcategory;
-
+        entitiesTicked = 0;
+        tilesTicked = 0;
+
+        long lastChunk = Long.MIN_VALUE; // Spigot - cache chunk x, z cords for unload queue
         for (i = 0; i < this.weatherEffects.size(); ++i)
         {
             entity = (Entity)this.weatherEffects.get(i);
+            // CraftBukkit start - Fixed an NPE, don't process entities in chunks queued for unload
+            if (entity == null)
+            {
+                continue;
+            }
+
+            ChunkProviderServer chunkProviderServer = ((WorldServer) this).theChunkProviderServer;
+            // Spigot start - check last chunk to see if this loaded (fast cache)
+            long chunk = org.bukkit.craftbukkit.util.LongHash.toLong(MathHelper.floor_double(entity.posX) >> 4, MathHelper.floor_double(entity.posZ) >> 4);
+
+            if (lastChunk != chunk) {
+                if (chunkProviderServer.chunksToUnload.contains(chunk)) { // Spigot end
+                    continue;
+                }
+            }
+            // CraftBukkit end
+            lastChunk = chunk; // Spigot
 
             try
             {
@@ -1990,7 +2635,15 @@
                     entity.addEntityCrashInfo(crashreportcategory);
                 }
 
-                throw new ReportedException(crashreport);
+                if (ForgeDummyContainer.removeErroringEntities)
+                {
+                    FMLLog.severe(crashreport.getCompleteReport());
+                    removeEntity(entity);
+                }
+                else
+                {
+                    throw new ReportedException(crashreport);
+                }
             }
 
             if (entity.isDead)
@@ -1999,6 +2652,7 @@
             }
         }
 
+        lastChunk = Long.MIN_VALUE; // Spigot
         this.theProfiler.endStartSection("remove");
         this.loadedEntityList.removeAll(this.unloadedEntityList);
         int j;
@@ -2023,10 +2677,23 @@
 
         this.unloadedEntityList.clear();
         this.theProfiler.endStartSection("regular");
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
 
         for (i = 0; i < this.loadedEntityList.size(); ++i)
         {
             entity = (Entity)this.loadedEntityList.get(i);
+            // CraftBukkit start - Don't tick entities in chunks queued for unload
+            ChunkProviderServer chunkProviderServer = ((WorldServer) this).theChunkProviderServer;
+            // Spigot start - check last chunk to see if this loaded (fast cache)
+            long chunk = org.bukkit.craftbukkit.util.LongHash.toLong(MathHelper.floor_double(entity.posX) >> 4, MathHelper.floor_double(entity.posZ) >> 4);
+            if (lastChunk != chunk) {
+                if (chunkProviderServer.chunksToUnload.contains(chunk)) { // Spigot end
+                    continue;
+                }
+            }
+            // CraftBukkit end
+            lastChunk = Long.MIN_VALUE; // Spigot
 
             if (entity.ridingEntity != null)
             {
@@ -2045,14 +2712,25 @@
             {
                 try
                 {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.updateEntity(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 }
                 catch (Throwable throwable1)
                 {
                     crashreport = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     crashreportcategory = crashreport.makeCategory("Entity being ticked");
                     entity.addEntityCrashInfo(crashreportcategory);
-                    throw new ReportedException(crashreport);
+
+                    if (ForgeDummyContainer.removeErroringEntities)
+                    {
+                        FMLLog.severe(crashreport.getCompleteReport());
+                        removeEntity(entity);
+                    }
+                    else
+                    {
+                        throw new ReportedException(crashreport);
+                    }
                 }
             }
 
@@ -2076,7 +2754,9 @@
             this.theProfiler.endSection();
         }
 
+        timings.entityTick.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tileEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
         this.scanningTileEntities = true;
         Iterator iterator = this.loadedTileEntityList.iterator();
 
@@ -2084,18 +2764,55 @@
         {
             TileEntity tileentity = (TileEntity)iterator.next();
 
+            // Spigot start
+            if (tileentity == null)
+            {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                iterator.remove();
+                continue;
+            }
+
+            // Spigot end
+            // CraftBukkit start - Don't tick entities in chunks queued for unload
+            ChunkProviderServer chunkProviderServer = ((WorldServer) this).theChunkProviderServer;
+            if (!isActiveBlockCoord(tileentity.xCoord, tileentity.zCoord)) continue; // MCPC+ don't tick inactive chunks
+            if (chunkProviderServer.chunksToUnload.contains(chunkToKey(tileentity.xCoord >> 4, tileentity.zCoord >> 4)))
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+
             if (!tileentity.isInvalid() && tileentity.hasWorldObj() && this.blockExists(tileentity.xCoord, tileentity.yCoord, tileentity.zCoord))
             {
                 try
                 {
-                    tileentity.updateEntity();
+                    tileentity.tickTimer.startTiming(); // Spigot
+                    // MCPC+ start - selectively tick entities
+                    if (!MCPCHooks.overrideTileTicks || MinecraftServer.getServer().getTickCounter() % MCPCHooks.getTileTickInterval(tileentity) == 0)
+                    {
+                        tilesTicked++;
+                        tileentity.updateEntity();
+                    }
+                    // MCPC+ stop
+                    tileentity.tickTimer.stopTiming(); // Spigot
                 }
                 catch (Throwable throwable2)
                 {
+                    tileentity.tickTimer.stopTiming(); // Spigot
                     crashreport = CrashReport.makeCrashReport(throwable2, "Ticking tile entity");
                     crashreportcategory = crashreport.makeCategory("Tile entity being ticked");
                     tileentity.func_85027_a(crashreportcategory);
-                    throw new ReportedException(crashreport);
+                    if (ForgeDummyContainer.removeErroringTileEntities)
+                    {
+                        FMLLog.severe(crashreport.getCompleteReport());
+                        tileentity.invalidate();
+                        setBlockToAir(tileentity.xCoord, tileentity.yCoord, tileentity.zCoord);
+                    }
+                    else
+                    {
+                        throw new ReportedException(crashreport);
+                    }
                 }
             }
 
@@ -2109,21 +2826,26 @@
 
                     if (chunk != null)
                     {
-                        chunk.removeChunkBlockTileEntity(tileentity.xCoord & 15, tileentity.yCoord, tileentity.zCoord & 15);
-                    }
-                }
-            }
-        }
-
+                        chunk.cleanChunkBlockTileEntity(tileentity.xCoord & 15, tileentity.yCoord, tileentity.zCoord & 15);
+                    }
+                }
+            }
+        }
+
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
+        this.scanningTileEntities = false;
 
         if (!this.entityRemoval.isEmpty())
         {
+            for (Object tile : entityRemoval)
+            {
+               ((TileEntity)tile).onChunkUnload();
+            }
             this.loadedTileEntityList.removeAll(this.entityRemoval);
             this.entityRemoval.clear();
         }
 
-        this.scanningTileEntities = false;
-
         this.theProfiler.endStartSection("pendingTileEntities");
 
         if (!this.addedTileEntityList.isEmpty())
@@ -2134,41 +2856,49 @@
 
                 if (!tileentity1.isInvalid())
                 {
+                    /* CraftBukkit start - Order matters, moved down
                     if (!this.loadedTileEntityList.contains(tileentity1))
                     {
                         this.loadedTileEntityList.add(tileentity1);
                     }
-
+                    // CraftBukkit end */
                     if (this.chunkExists(tileentity1.xCoord >> 4, tileentity1.zCoord >> 4))
                     {
                         Chunk chunk1 = this.getChunkFromChunkCoords(tileentity1.xCoord >> 4, tileentity1.zCoord >> 4);
 
                         if (chunk1 != null)
                         {
-                            chunk1.setChunkBlockTileEntity(tileentity1.xCoord & 15, tileentity1.yCoord, tileentity1.zCoord & 15, tileentity1);
+                            chunk1.cleanChunkBlockTileEntity(tileentity1.xCoord & 15, tileentity1.yCoord, tileentity1.zCoord & 15);
+
+                            // CraftBukkit start - Moved down from above
+                            if (!this.loadedTileEntityList.contains(tileentity1))
+                            {
+                                this.loadedTileEntityList.add(tileentity1);
+                            }
+
+                            // CraftBukkit end
                         }
                     }
-
-                    this.markBlockForUpdate(tileentity1.xCoord, tileentity1.yCoord, tileentity1.zCoord);
                 }
             }
 
             this.addedTileEntityList.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
         this.theProfiler.endSection();
         this.theProfiler.endSection();
     }
 
     public void addTileEntity(Collection par1Collection)
     {
-        if (this.scanningTileEntities)
-        {
-            this.addedTileEntityList.addAll(par1Collection);
-        }
-        else
-        {
-            this.loadedTileEntityList.addAll(par1Collection);
+        Collection dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList; // MCPC+ - List -> Collection for CB loadedTileEntityList type change
+        for(Object entity : par1Collection)
+        {
+            if(MCPCHooks.canUpdate((TileEntity)entity))
+            {
+                dest.add(entity);
+            }
         }
     }
 
@@ -2180,6 +2910,9 @@
         this.updateEntityWithOptionalForce(par1Entity, true);
     }
 
+    public int entitiesTicked;
+    public int tilesTicked;
+    
     /**
      * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
      * Args: entity, forceUpdate
@@ -2188,10 +2921,31 @@
     {
         int i = MathHelper.floor_double(par1Entity.posX);
         int j = MathHelper.floor_double(par1Entity.posZ);
-        byte b0 = 32;
-
-        if (!par2 || this.checkChunksExist(i - b0, 0, j - b0, i + b0, 0, j + b0))
-        {
+
+        // MCPC+ start - this breaks chunkloaders such as AnchorCart used by Railcraft. It prevents the cart from sending EntityEvent.EnteringChunk which causes it to halt
+        // Spigot start
+        if (!org.spigotmc.ActivationRange.checkIfActive(par1Entity))
+        {
+            par1Entity.ticksExisted++;
+            par1Entity.inactiveTick();
+            return;
+        }
+        par1Entity.tickTimer.startTiming();
+        // Spigot end        
+
+        boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(i >> 4, j >> 4));
+        byte b0 = isForced ? (byte)0 : 32;
+        boolean canUpdate = !par2 || (isActiveBlockCoord(i, j) && this.checkChunksExist(i - b0, 0, j - b0, i + b0, 0, j + b0));
+        if (!canUpdate)
+        {
+            EntityEvent.CanUpdate event = new EntityEvent.CanUpdate(par1Entity);
+            MinecraftForge.EVENT_BUS.post(event);
+            canUpdate = event.canUpdate;
+        }
+        if (canUpdate && !isActiveBlockCoord(i,j)) canUpdate = false; // MCPC+ don't update entities in inactive chunks
+        if (canUpdate)
+        {
+            entitiesTicked++;
             par1Entity.lastTickPosX = par1Entity.posX;
             par1Entity.lastTickPosY = par1Entity.posY;
             par1Entity.lastTickPosZ = par1Entity.posZ;
@@ -2275,6 +3029,7 @@
                     par1Entity.riddenByEntity = null;
                 }
             }
+            par1Entity.tickTimer.stopTiming(); // Spigot
         }
     }
 
@@ -2424,6 +3179,14 @@
                         {
                             return true;
                         }
+                        else
+                        {
+                            Block block = Block.blocksList[j2];
+                            if (block != null && block.isBlockBurning(this, k1, l1, i2))
+                            {
+                                return true;
+                            }
+                        }
                     }
                 }
             }
@@ -2484,6 +3247,7 @@
                 par3Entity.motionZ += vec3.zCoord * d1;
             }
 
+            vec3.myVec3LocalPool.release(vec3); // CraftBukkit - pop it - we're done
             return flag;
         }
     }
@@ -2592,6 +3356,7 @@
         double d2 = 1.0D / ((par2AxisAlignedBB.maxZ - par2AxisAlignedBB.minZ) * 2.0D + 1.0D);
         int i = 0;
         int j = 0;
+        Vec3 vec32 = par1Vec3.myVec3LocalPool.getVecFromPool(0, 0, 0); // CraftBukkit
 
         for (float f = 0.0F; f <= 1.0F; f = (float)((double)f + d0))
         {
@@ -2603,7 +3368,7 @@
                     double d4 = par2AxisAlignedBB.minY + (par2AxisAlignedBB.maxY - par2AxisAlignedBB.minY) * (double)f1;
                     double d5 = par2AxisAlignedBB.minZ + (par2AxisAlignedBB.maxZ - par2AxisAlignedBB.minZ) * (double)f2;
 
-                    if (this.clip(this.getWorldVec3Pool().getVecFromPool(d3, d4, d5), par1Vec3) == null)
+                    if (this.clip(vec32.func_72439_b_CodeFix_Public(d3, d4, d5), par1Vec3) == null)   // CraftBukkit
                     {
                         ++i;
                     }
@@ -2613,6 +3378,7 @@
             }
         }
 
+        vec32.myVec3LocalPool.release(vec32); // CraftBukkit
         return (float)i / (float)j;
     }
 
@@ -2746,15 +3512,16 @@
      */
     public void setBlockTileEntity(int par1, int par2, int par3, TileEntity par4TileEntity)
     {
-        if (par4TileEntity != null && !par4TileEntity.isInvalid())
-        {
-            if (this.scanningTileEntities)
-            {
-                par4TileEntity.xCoord = par1;
-                par4TileEntity.yCoord = par2;
-                par4TileEntity.zCoord = par3;
-                Iterator iterator = this.addedTileEntityList.iterator();
-
+        if (par4TileEntity == null || par4TileEntity.isInvalid())
+        {
+            return;
+        }
+
+        if (MCPCHooks.canUpdate(par4TileEntity))
+        {
+            if (scanningTileEntities)
+            {
+                Iterator iterator = addedTileEntityList.iterator();
                 while (iterator.hasNext())
                 {
                     TileEntity tileentity1 = (TileEntity)iterator.next();
@@ -2765,20 +3532,21 @@
                         iterator.remove();
                     }
                 }
-
-                this.addedTileEntityList.add(par4TileEntity);
+                addedTileEntityList.add(par4TileEntity);
             }
             else
             {
-                this.loadedTileEntityList.add(par4TileEntity);
-                Chunk chunk = this.getChunkFromChunkCoords(par1 >> 4, par3 >> 4);
-
-                if (chunk != null)
-                {
-                    chunk.setChunkBlockTileEntity(par1 & 15, par2, par3 & 15, par4TileEntity);
-                }
-            }
-        }
+                loadedTileEntityList.add(par4TileEntity);
+            }
+        }
+
+        Chunk chunk = this.getChunkFromChunkCoords(par1 >> 4, par3 >> 4);
+        if (chunk != null)
+        {
+            chunk.setChunkBlockTileEntity(par1 & 15, par2, par3 & 15, par4TileEntity);
+        }
+        //notify tile changes
+        func_96440_m(par1, par2, par3, 0);
     }
 
     /**
@@ -2786,28 +3554,13 @@
      */
     public void removeBlockTileEntity(int par1, int par2, int par3)
     {
-        TileEntity tileentity = this.getBlockTileEntity(par1, par2, par3);
-
-        if (tileentity != null && this.scanningTileEntities)
-        {
-            tileentity.invalidate();
-            this.addedTileEntityList.remove(tileentity);
-        }
-        else
-        {
-            if (tileentity != null)
-            {
-                this.addedTileEntityList.remove(tileentity);
-                this.loadedTileEntityList.remove(tileentity);
-            }
-
-            Chunk chunk = this.getChunkFromChunkCoords(par1 >> 4, par3 >> 4);
-
-            if (chunk != null)
-            {
-                chunk.removeChunkBlockTileEntity(par1 & 15, par2, par3 & 15);
-            }
-        }
+        Chunk chunk = getChunkFromChunkCoords(par1 >> 4, par3 >> 4);
+        if (chunk != null)
+        {
+            chunk.removeChunkBlockTileEntity(par1 & 15, par2, par3 & 15);
+        }
+        //notify tile changes
+        func_96440_m(par1, par2, par3, 0);
     }
 
     /**
@@ -2832,7 +3585,8 @@
      */
     public boolean isBlockNormalCube(int par1, int par2, int par3)
     {
-        return Block.isNormalCube(this.getBlockId(par1, par2, par3));
+        Block block = Block.blocksList[getBlockId(par1, par2, par3)];
+        return block != null && block.isBlockNormalCube(this, par1, par2, par3);
     }
 
     public boolean isBlockFullCube(int par1, int par2, int par3)
@@ -2855,16 +3609,17 @@
      */
     public boolean doesBlockHaveSolidTopSurface(int par1, int par2, int par3)
     {
-        Block block = Block.blocksList[this.getBlockId(par1, par2, par3)];
-        return this.isBlockTopFacingSurfaceSolid(block, this.getBlockMetadata(par1, par2, par3));
+        return isBlockSolidOnSide(par1, par2, par3, ForgeDirection.UP);
     }
 
     /**
      * Performs check to see if the block is a normal, solid block, or if the metadata of the block indicates that its
      * facing puts its solid side upwards. (inverted stairs, for example)
      */
+    @Deprecated //DO NOT USE THIS!!! USE doesBlockHaveSolidTopSurface
     public boolean isBlockTopFacingSurfaceSolid(Block par1Block, int par2)
     {
+        // -.-  Mojang PLEASE make this location sensitive, you have no reason not to.
         return par1Block == null ? false : (par1Block.blockMaterial.isOpaque() && par1Block.renderAsNormalBlock() ? true : (par1Block instanceof BlockStairs ? (par2 & 4) == 4 : (par1Block instanceof BlockHalfSlab ? (par2 & 8) == 8 : (par1Block instanceof BlockHopper ? true : (par1Block instanceof BlockSnow ? (par2 & 7) == 7 : false)))));
     }
 
@@ -2881,7 +3636,7 @@
             if (chunk != null && !chunk.isEmpty())
             {
                 Block block = Block.blocksList[this.getBlockId(par1, par2, par3)];
-                return block == null ? false : block.blockMaterial.isOpaque() && block.renderAsNormalBlock();
+                return block == null ? false : isBlockNormalCube(par1, par2, par3);
             }
             else
             {
@@ -2912,8 +3667,7 @@
      */
     public void setAllowedSpawnTypes(boolean par1, boolean par2)
     {
-        this.spawnHostileMobs = par1;
-        this.spawnPeacefulMobs = par2;
+        provider.setAllowedSpawnTypes(par1, par2);
     }
 
     /**
@@ -2929,6 +3683,11 @@
      */
     private void calculateInitialWeather()
     {
+        provider.calculateInitialWeather();
+    }
+
+    public void calculateInitialWeatherBody()
+    {
         if (this.worldInfo.isRaining())
         {
             this.rainingStrength = 1.0F;
@@ -2944,6 +3703,11 @@
      * Updates all weather states.
      */
     protected void updateWeather()
+    {
+        provider.updateWeather();
+    }
+
+    public void updateWeatherBody()
     {
         if (!this.provider.hasNoSky)
         {
@@ -2967,7 +3731,14 @@
 
                 if (i <= 0)
                 {
-                    this.worldInfo.setThundering(!this.worldInfo.isThundering());
+                    // CraftBukkit start
+                    ThunderChangeEvent thunder = new ThunderChangeEvent(this.getWorld(), !this.worldInfo.isThundering());
+                    this.getServer().getPluginManager().callEvent(thunder);
+                    if (!thunder.isCancelled())
+                    {
+                        this.worldInfo.setThundering(!this.worldInfo.isThundering());
+                    }
+                    // CraftBukkit end
                 }
             }
 
@@ -2991,7 +3762,14 @@
 
                 if (j <= 0)
                 {
-                    this.worldInfo.setRaining(!this.worldInfo.isRaining());
+                    // CraftBukkit start
+                    WeatherChangeEvent weather = new WeatherChangeEvent(this.getWorld(), !this.worldInfo.isRaining());
+                    this.getServer().getPluginManager().callEvent(weather);
+                    if (!weather.isCancelled())
+                    {
+                        this.worldInfo.setRaining(!this.worldInfo.isRaining());
+                    }
+                    // CraftBukkit end
                 }
             }
 
@@ -3041,34 +3819,81 @@
 
     public void toggleRain()
     {
-        this.worldInfo.setRainTime(1);
-    }
+        provider.toggleRain();
+    }
+
+    // Spigot start
+    protected float modifiedOdds = 100F;
+    public float growthOdds = 100F;
 
     protected void setActivePlayerChunksAndCheckLight()
     {
-        this.activeChunkSet.clear();
+        // MCPC+ start - add persistent chunks to be ticked for growth
+        activeChunkSet.clear();
+        activeChunkSet_CB.clear();
+        for(ChunkCoordIntPair chunk : getPersistentChunks().keySet()) {
+            this.activeChunkSet.add(chunk);
+            long key = chunkToKey(chunk.chunkXPos, chunk.chunkZPos);
+            activeChunkSet_CB.put(key, (short) 0);
+            if (!this.chunkExists(chunk.chunkXPos, chunk.chunkZPos)) {
+                ((WorldServer)this).theChunkProviderServer.loadChunk(chunk.chunkXPos, chunk.chunkZPos);
+            }
+        }
+        // MCPC+ end
+
+        // this.chunkTickList.clear(); // CraftBukkit - removed
         this.theProfiler.startSection("buildList");
         int i;
         EntityPlayer entityplayer;
         int j;
         int k;
-
+        final int optimalChunks = spigotConfig.chunksPerTick;
+
+        if (optimalChunks <= 0) // MCPC+ tick chunks even if no players are logged in
+        {
+            return;
+        }
+
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min(200, Math.max(1, (int)(((optimalChunks - playerEntities.size()) / (double) playerEntities.size()) + 0.5)));
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
+        // Spigot end
         for (i = 0; i < this.playerEntities.size(); ++i)
         {
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
-            j = MathHelper.floor_double(entityplayer.posX / 16.0D);
-            k = MathHelper.floor_double(entityplayer.posZ / 16.0D);
-            byte b0 = 7;
-
-            for (int l = -b0; l <= b0; ++l)
-            {
-                for (int i1 = -b0; i1 <= b0; ++i1)
-                {
-                    this.activeChunkSet.add(new ChunkCoordIntPair(l + j, i1 + k));
-                }
-            }
-        }
-
+            int chunkX = MathHelper.floor_double(entityplayer.posX / 16.0D);
+            int chunkZ = MathHelper.floor_double(entityplayer.posZ / 16.0D);
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey(chunkX, chunkZ);
+            int existingPlayers = Math.max(0, activeChunkSet_CB.get(key)); //filter out -1's
+            activeChunkSet_CB.put(key, (short)(existingPlayers + 1));
+            activeChunkSet.add(new ChunkCoordIntPair(chunkX, chunkZ)); // MCPC+ - vanilla compatibility
+
+            // Check and see if we update the chunks surrounding the player this tick
+            for (int chunk = 0; chunk < chunksPerPlayer; chunk++)
+            {
+                int dx = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                int dz = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(randRange);
+                long hash = chunkToKey(dx + chunkX, dz + chunkZ);
+
+                if (!activeChunkSet_CB.contains(hash) && this.chunkExists(dx + chunkX, dz + chunkZ))
+                {
+                    activeChunkSet_CB.put(hash, (short) - 1); //no players
+                    activeChunkSet.add(new ChunkCoordIntPair(dx + chunkX, dz + chunkZ)); // MCPC+ - vanilla compatibility
+                }
+            }
+        }
+        /*for (ChunkCoordIntPair coord : getPersistentChunks().keySet())
+        {
+            long key = chunkToKey(coord.chunkXPos, coord.chunkZPos);
+            activeChunkSet.put(key, (short) - 1); //no players
+        }*/
+
+        // Spigot End
         this.theProfiler.endSection();
 
         if (this.ambientTickCountdown > 0)
@@ -3078,7 +3903,7 @@
 
         this.theProfiler.startSection("playerCheckLight");
 
-        if (!this.playerEntities.isEmpty())
+        if (spigotConfig.randomLightUpdates && !this.playerEntities.isEmpty()) // Spigot
         {
             i = this.rand.nextInt(this.playerEntities.size());
             entityplayer = (EntityPlayer)this.playerEntities.get(i);
@@ -3101,7 +3926,7 @@
             int k = this.updateLCG >> 2;
             int l = k & 15;
             int i1 = k >> 8 & 15;
-            int j1 = k >> 16 & 127;
+            int j1 = k >> 16 & 255; // CraftBukkit - 127 -> 255
             int k1 = par3Chunk.getBlockID(l, j1, i1);
             l += par1;
             i1 += par2;
@@ -3153,6 +3978,11 @@
      */
     public boolean canBlockFreeze(int par1, int par2, int par3, boolean par4)
     {
+        return provider.canBlockFreeze(par1, par2, par3, par4);
+    }
+
+    public boolean canBlockFreezeBody(int par1, int par2, int par3, boolean par4)
+    {
         BiomeGenBase biomegenbase = this.getBiomeGenForCoords(par1, par3);
         float f = biomegenbase.getFloatTemperature();
 
@@ -3211,6 +4041,11 @@
      */
     public boolean canSnowAt(int par1, int par2, int par3)
     {
+        return provider.canSnowAt(par1, par2, par3);
+    }
+
+    public boolean canSnowAtBody(int par1, int par2, int par3)
+    {
         BiomeGenBase biomegenbase = this.getBiomeGenForCoords(par1, par3);
         float f = biomegenbase.getFloatTemperature();
 
@@ -3254,10 +4089,12 @@
         else
         {
             int l = this.getBlockId(par1, par2, par3);
-            int i1 = par4EnumSkyBlock == EnumSkyBlock.Sky ? 0 : Block.lightValue[l];
-            int j1 = Block.lightOpacity[l];
-
-            if (j1 >= 15 && Block.lightValue[l] > 0)
+            Block block = Block.blocksList[l];
+            int blockLight = (block == null ? 0 : block.getLightValue(this, par1, par2, par3));
+            int i1 = par4EnumSkyBlock == EnumSkyBlock.Sky ? 0 : blockLight;
+            int j1 = (block == null ? 0 : block.getLightOpacity(this, par1, par2, par3));
+
+            if (j1 >= 15 && blockLight > 0)
             {
                 j1 = 1;
             }
@@ -3353,7 +4190,9 @@
                                     int j4 = i2 + Facing.offsetsXForSide[i4];
                                     int k4 = j2 + Facing.offsetsYForSide[i4];
                                     int l4 = k2 + Facing.offsetsZForSide[i4];
-                                    int i5 = Math.max(1, Block.lightOpacity[this.getBlockId(j4, k4, l4)]);
+                                    Block block = Block.blocksList[getBlockId(j4, k4, l4)];
+                                    int blockOpacity = (block == null ? 0 : block.getLightOpacity(this, j4, k4, l4));
+                                    int i5 = Math.max(1, blockOpacity);
                                     i3 = this.getSavedLightValue(par1EnumSkyBlock, j4, k4, l4);
 
                                     if (i3 == l2 - i5 && i1 < this.lightUpdateBlockList.length)
@@ -3456,10 +4295,10 @@
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
         ArrayList arraylist = new ArrayList();
-        int i = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
-        int j = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
-        int k = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
-        int l = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        int i = MathHelper.floor_double((par2AxisAlignedBB.minX - MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor_double((par2AxisAlignedBB.maxX + MAX_ENTITY_RADIUS) / 16.0D);
+        int k = MathHelper.floor_double((par2AxisAlignedBB.minZ - MAX_ENTITY_RADIUS) / 16.0D);
+        int l = MathHelper.floor_double((par2AxisAlignedBB.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
 
         for (int i1 = i; i1 <= j; ++i1)
         {
@@ -3485,10 +4324,10 @@
 
     public List selectEntitiesWithinAABB(Class par1Class, AxisAlignedBB par2AxisAlignedBB, IEntitySelector par3IEntitySelector)
     {
-        int i = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
-        int j = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
-        int k = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
-        int l = MathHelper.floor_double((par2AxisAlignedBB.maxZ + 2.0D) / 16.0D);
+        int i = MathHelper.floor_double((par2AxisAlignedBB.minX - MAX_ENTITY_RADIUS) / 16.0D);
+        int j = MathHelper.floor_double((par2AxisAlignedBB.maxX + MAX_ENTITY_RADIUS) / 16.0D);
+        int k = MathHelper.floor_double((par2AxisAlignedBB.minZ - MAX_ENTITY_RADIUS) / 16.0D);
+        int l = MathHelper.floor_double((par2AxisAlignedBB.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
         ArrayList arraylist = new ArrayList();
 
         for (int i1 = i; i1 <= j; ++i1)
@@ -3568,10 +4407,23 @@
         {
             Entity entity = (Entity)this.loadedEntityList.get(j);
 
-            if ((!(entity instanceof EntityLiving) || !((EntityLiving)entity).isNoDespawnRequired()) && par1Class.isAssignableFrom(entity.getClass()))
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityLiving)
+            {
+                EntityLiving entityliving = (EntityLiving) entity;
+
+                if (entityliving.func_70692_ba_CodeFix_Public() && entityliving.isNoDespawnRequired())   // Should be isPersistent
+                {
+                    continue;
+                }
+            }
+
+            if (par1Class.isAssignableFrom(entity.getClass()))
             {
                 ++i;
             }
+
+            // CraftBukkit end
         }
 
         return i;
@@ -3582,11 +4434,24 @@
      */
     public void addLoadedEntities(List par1List)
     {
-        this.loadedEntityList.addAll(par1List);
+        // CraftBukkit start
+        Entity entity = null;
 
         for (int i = 0; i < par1List.size(); ++i)
         {
-            this.onEntityAdded((Entity)par1List.get(i));
+            entity = (Entity) par1List.get(i);
+
+            if (entity == null)
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+            if (!MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(entity, this)))
+            {
+                loadedEntityList.add(entity);
+                this.onEntityAdded(entity);
+            }
         }
     }
 
@@ -3613,9 +4478,11 @@
             axisalignedbb = null;
         }
 
+        boolean defaultReturn; // CraftBukkit - store the default action
+
         if (axisalignedbb != null && !this.checkNoEntityCollision(axisalignedbb, par7Entity))
         {
-            return false;
+            defaultReturn = false; // CraftBukkit
         }
         else
         {
@@ -3624,8 +4491,65 @@
                 block = null;
             }
 
-            return block != null && block.blockMaterial == Material.circuits && block1 == Block.anvil ? true : par1 > 0 && block == null && block1.canPlaceBlockOnSide(this, par2, par3, par4, par6, par8ItemStack);
-        }
+            // CraftBukkit
+            defaultReturn = block != null && block.blockMaterial == Material.circuits && block1 == Block.anvil ? true : par1 > 0 && block == null && block1.canPlaceBlockOnSide(this, par2, par3, par4, par6, par8ItemStack);
+        }
+
+        // CraftBukkit start
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(par2, par3, par4), par1, defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+        boolean result = event.isBuildable();
+        // MCPC+ start - all forge blocks will now send a BlockPlaceEvent here to allow events to occur with mods 
+        //               that override ItemBlock.onItemUse and ItemBlock.placeBlockAt such as RP2's microblocks, BC pipes, etc.
+        if (par7Entity != null && !this.callingPlaceEvent && block1 != null && block1.isForgeBlock && result)
+        {
+            if (par7Entity instanceof EntityPlayer)
+            {
+                EntityPlayer player = (EntityPlayer)par7Entity;
+                ItemStack itemstack = (player.getCurrentEquippedItem() != null ? player.getCurrentEquippedItem() : null);
+                NBTTagCompound savedCompound = null;
+                // workaround for MFR DSU's
+                if (itemstack != null && itemstack.getTagCompound() != null && (itemstack.getUnlocalizedName()).contains("deepstorageunit"))
+                {
+                    savedCompound = itemstack.getTagCompound(); // save current itemstack NBT
+                    itemstack.setTagCompound(new NBTTagCompound()); // dont use any itemstack NBT in our simulation, fixes MFR DSU dupe
+                }
+
+                org.bukkit.block.BlockState blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, par2, par3, par4);
+                this.callingPlaceEvent = true;
+                int metadata = 0;
+                if (itemstack != null && itemstack.getItem() instanceof ItemBlock)
+                {
+                    ItemBlock itemblock = (ItemBlock)itemstack.getItem();
+                    int itemData = itemblock.getMetadata(itemstack.getItemDamage());
+                    metadata = Block.blocksList[par1].onBlockPlaced(this, par2, par3, par4, par6, this.curPlacedItemHitX, this.curPlacedItemHitY, this.curPlacedItemHitZ, itemData);
+                    if (itemblock.placeBlockAt(itemstack, player, this, par2, par3, par4, par6, this.curPlacedItemHitX, this.curPlacedItemHitY, this.curPlacedItemHitZ, metadata))
+                    {
+                        // since this is only a simulation, there is no need to play sound or decrement stacksize
+                    }
+                }
+                this.curPlacedItemHitX = 0;
+                this.curPlacedItemHitY = 0;
+                this.curPlacedItemHitZ = 0;
+
+                // send place event
+                org.bukkit.event.block.BlockPlaceEvent placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(this, player, blockstate, par2, par3, par4);
+
+                if (placeEvent.isCancelled() || !placeEvent.canBuild())
+                {
+                    result = false; // cancel placement
+                }
+
+                blockstate.update(true, false); // revert blockstate since this was only a simulation
+                this.callingPlaceEvent = false;
+                if (savedCompound != null)
+                {
+                    itemstack.setTagCompound(savedCompound); // restore itemstack NBT
+                }
+            }
+        }
+        return result;
+        // MCPC+ end
     }
 
     public PathEntity getPathEntityToEntity(Entity par1Entity, Entity par2Entity, float par3, boolean par4, boolean par5, boolean par6, boolean par7)
@@ -3744,14 +4668,20 @@
      */
     public int getIndirectPowerLevelTo(int par1, int par2, int par3, int par4)
     {
-        if (this.isBlockNormalCube(par1, par2, par3))
+        Block block = Block.blocksList[this.getBlockId(par1, par2, par3)];
+
+        if (block == null)
+        {
+            return 0;
+        }
+
+        if (!block.shouldCheckWeakPower(this, par1, par2, par3, par4))
         {
             return this.getBlockPowerInput(par1, par2, par3);
         }
         else
         {
-            int i1 = this.getBlockId(par1, par2, par3);
-            return i1 == 0 ? 0 : Block.blocksList[i1].isProvidingWeakPower(this, par1, par2, par3, par4);
+            return block.isProvidingWeakPower(this, par1, par2, par3, par4);
         }
     }
 
@@ -3807,6 +4737,12 @@
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
             EntityPlayer entityplayer1 = (EntityPlayer)this.playerEntities.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead)
+            {
+                continue;
+            }
+            // CraftBukkit end
             double d5 = entityplayer1.getDistanceSq(par1, par3, par5);
 
             if ((par7 < 0.0D || d5 < par7 * par7) && (d4 == -1.0D || d5 < d4))
@@ -3838,6 +4774,12 @@
         for (int i = 0; i < this.playerEntities.size(); ++i)
         {
             EntityPlayer entityplayer1 = (EntityPlayer)this.playerEntities.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityplayer1 == null || entityplayer1.isDead)
+            {
+                continue;
+            }
+            // CraftBukkit end
 
             if (!entityplayer1.capabilities.disableDamage && entityplayer1.isEntityAlive())
             {
@@ -3914,7 +4856,7 @@
      */
     public long getSeed()
     {
-        return this.worldInfo.getSeed();
+        return provider.getSeed();
     }
 
     public long getTotalWorldTime()
@@ -3924,7 +4866,7 @@
 
     public long getWorldTime()
     {
-        return this.worldInfo.getWorldTime();
+        return provider.getWorldTime();
     }
 
     /**
@@ -3932,7 +4874,7 @@
      */
     public void setWorldTime(long par1)
     {
-        this.worldInfo.setWorldTime(par1);
+        provider.setWorldTime(par1);
     }
 
     /**
@@ -3940,13 +4882,13 @@
      */
     public ChunkCoordinates getSpawnPoint()
     {
-        return new ChunkCoordinates(this.worldInfo.getSpawnX(), this.worldInfo.getSpawnY(), this.worldInfo.getSpawnZ());
+        return provider.getSpawnPoint();
     }
 
     @SideOnly(Side.CLIENT)
     public void setSpawnLocation(int par1, int par2, int par3)
     {
-        this.worldInfo.setSpawnPosition(par1, par2, par3);
+        provider.setSpawnPoint(par1, par2, par3);
     }
 
     @SideOnly(Side.CLIENT)
@@ -3970,7 +4912,10 @@
 
         if (!this.loadedEntityList.contains(par1Entity))
         {
-            this.loadedEntityList.add(par1Entity);
+            if (!MinecraftForge.EVENT_BUS.post(new EntityJoinWorldEvent(par1Entity, this)))
+            {
+                loadedEntityList.add(par1Entity);
+            }
         }
     }
 
@@ -3978,6 +4923,11 @@
      * Called when checking if a certain block can be mined or not. The 'spawn safe zone' check is located here.
      */
     public boolean canMineBlock(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
+    {
+        return provider.canMineBlock(par1EntityPlayer, par2, par3, par4);
+    }
+
+    public boolean canMineBlockBody(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
     {
         return true;
     }
@@ -4036,6 +4986,18 @@
      */
     public void updateAllPlayersSleepingFlag() {}
 
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus()
+    {
+        if (!this.isRemote)
+        {
+            this.updateAllPlayersSleepingFlag();
+        }
+    }
+    // CraftBukkit end
+
     public float getWeightedThunderStrength(float par1)
     {
         return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * par1) * this.getRainStrength(par1);
@@ -4098,8 +5060,7 @@
      */
     public boolean isBlockHighHumidity(int par1, int par2, int par3)
     {
-        BiomeGenBase biomegenbase = this.getBiomeGenForCoords(par1, par3);
-        return biomegenbase.isHighHumidity();
+        return provider.isBlockHighHumidity(par1, par2, par3);
     }
 
     /**
@@ -4174,7 +5135,7 @@
      */
     public int getHeight()
     {
-        return 256;
+        return provider.getHeight();
     }
 
     /**
@@ -4182,7 +5143,7 @@
      */
     public int getActualHeight()
     {
-        return this.provider.hasNoSky ? 128 : 256;
+        return provider.getActualHeight();
     }
 
     public IUpdatePlayerListBox getMinecartSoundUpdater(EntityMinecart par1EntityMinecart)
@@ -4225,7 +5186,7 @@
      */
     public double getHorizon()
     {
-        return this.worldInfo.getTerrainType().getHorizon(this);
+        return provider.getHorizon();
     }
 
     /**
@@ -4294,30 +5255,28 @@
 
     public void func_96440_m(int par1, int par2, int par3, int par4)
     {
-        for (int i1 = 0; i1 < 4; ++i1)
-        {
-            int j1 = par1 + Direction.offsetX[i1];
-            int k1 = par3 + Direction.offsetZ[i1];
-            int l1 = this.getBlockId(j1, par2, k1);
-
-            if (l1 != 0)
-            {
-                Block block = Block.blocksList[l1];
-
-                if (Block.redstoneComparatorIdle.func_94487_f(l1))
-                {
-                    block.onNeighborBlockChange(this, j1, par2, k1, par4);
-                }
-                else if (Block.isNormalCube(l1))
-                {
-                    j1 += Direction.offsetX[i1];
-                    k1 += Direction.offsetZ[i1];
-                    l1 = this.getBlockId(j1, par2, k1);
+        for(ForgeDirection dir : ForgeDirection.VALID_DIRECTIONS)
+        {
+            int j1 = par1 + dir.offsetX;
+            int y = par2 + dir.offsetY;
+            int k1 = par3 + dir.offsetZ;
+            int l1 = getBlockId(j1, y, k1);
+            Block block = Block.blocksList[l1];
+
+            if(block != null)
+            {
+                block.onNeighborTileChange(this, j1, y, k1, par1, par2, par3);
+
+                if(Block.isNormalCube(l1))
+                {
+                    j1 += dir.offsetX;
+                    y += dir.offsetY;
+                    k1 += dir.offsetZ;
+                    l1 = getBlockId(j1, y, k1);
                     block = Block.blocksList[l1];
-
-                    if (Block.redstoneComparatorIdle.func_94487_f(l1))
-                    {
-                        block.onNeighborBlockChange(this, j1, par2, k1, par4);
+                    if(block != null && block.weakTileChanges())
+                    {
+                        block.onNeighborTileChange(this, j1, y, k1, par1, par2, par3);
                     }
                 }
             }
@@ -4363,4 +5322,141 @@
 
         return MathHelper.clamp_float(f, 0.0F, flag ? 1.5F : 1.0F);
     }
+
+    public boolean func_72916_c_CodeFix_Public(int a, int b){
+        return chunkExists(a, b);
+    }
+
+    /**
+     * Adds a single TileEntity to the world.
+     * @param entity The TileEntity to be added.
+     */
+    public void addTileEntity(TileEntity entity)
+    {
+        Collection dest = scanningTileEntities ? addedTileEntityList : loadedTileEntityList; // MCPC+ - List -> Collection for CB loadedTileEntityList type change
+        if(MCPCHooks.canUpdate(entity))
+        {
+            dest.add(entity);
+        }
+    }
+
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     *
+     * @param x Block X Position
+     * @param y Block Y Position
+     * @param z Block Z Position
+     * @param side The Side in question
+     * @return True if the side is solid
+     */
+    public boolean isBlockSolidOnSide(int x, int y, int z, ForgeDirection side)
+    {
+        return isBlockSolidOnSide(x, y, z, side, false);
+    }
+
+    /**
+     * Determine if the given block is considered solid on the
+     * specified side.  Used by placement logic.
+     *
+     * @param x Block X Position
+     * @param y Block Y Position
+     * @param z Block Z Position
+     * @param side The Side in question
+     * @param _default The defult to return if the block doesn't exist.
+     * @return True if the side is solid
+     */
+    @Override
+    public boolean isBlockSolidOnSide(int x, int y, int z, ForgeDirection side, boolean _default)
+    {
+        if (x < -30000000 || z < -30000000 || x >= 30000000 || z >= 30000000)
+        {
+            return _default;
+        }
+
+        Chunk chunk = this.chunkProvider.provideChunk(x >> 4, z >> 4);
+        if (chunk == null || chunk.isEmpty())
+        {
+            return _default;
+        }
+
+        Block block = Block.blocksList[getBlockId(x, y, z)];
+        if(block == null)
+        {
+            return false;
+        }
+
+        return block.isBlockSolidOnSide(this, x, y, z, side);
+    }
+
+    /**
+     * Get the persistent chunks for this world
+     *
+     * @return
+     */
+    public ImmutableSetMultimap<ChunkCoordIntPair, Ticket> getPersistentChunks()
+    {
+        return ForgeChunkManager.getPersistentChunksFor(this);
+    }
+
+    /**
+     * Readded as it was removed, very useful helper function
+     *
+     * @param x X position
+     * @param y Y Position
+     * @param z Z Position
+     * @return The blocks light opacity
+     */
+    public int getBlockLightOpacity(int x, int y, int z)
+    {
+        if (x < -30000000 || z < -30000000 || x >= 30000000 || z >= 30000000)
+        {
+            return 0;
+        }
+
+        if (y < 0 || y >= 256)
+        {
+            return 0;
+        }
+
+        return getChunkFromChunkCoords(x >> 4, z >> 4).getBlockLightOpacity(x & 15, y, z & 15);
+    }
+
+    /**
+     * Returns a count of entities that classify themselves as the specified creature type.
+     */
+    public int countEntities(EnumCreatureType type, boolean forSpawnCount)
+    {
+        int count = 0;
+        for (int x = 0; x < loadedEntityList.size(); x++)
+        {
+            if (((Entity)loadedEntityList.get(x)).isCreatureType(type, forSpawnCount))
+            {
+                count++;
+            }
+        }
+        return count;
+    }
+    
+    // MCPC+ start
+    public boolean isActiveChunk(int x, int z)
+    {
+        return getPersistentChunks().containsKey(new ChunkCoordIntPair(x, z)) || activeChunkSet_CB.containsKey(chunkToKey(x, z));
+    }
+
+    public boolean isActiveChunk(long key)
+    {
+        return isActiveChunk(keyToX(key), keyToZ(key));
+    }
+
+    public boolean isActiveBlockCoord(int x, int z)
+    {
+        return isActiveChunk(x >> 4, z >> 4);
+    }
+    
+    public boolean inActiveChunk(Entity entity)
+    {
+        return isActiveBlockCoord(MathHelper.floor_double(entity.posX), MathHelper.floor_double(entity.posZ));
+    }
+    // MCPC+ end
 }
