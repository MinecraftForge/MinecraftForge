--- ../src_base/minecraft/net/minecraft/world/WorldServer.java
+++ ../src_work/minecraft/net/minecraft/world/WorldServer.java
@@ -2,14 +2,20 @@
 
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
+
+import java.io.File;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
+
+import gnu.trove.iterator.TLongShortIterator;
 import net.minecraft.block.Block;
+import net.minecraft.block.BlockContainer;
 import net.minecraft.block.BlockEventData;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
@@ -35,6 +41,18 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.management.PlayerManager;
 import net.minecraft.tileentity.TileEntity;
+import net.minecraft.tileentity.TileEntityBeacon;
+import net.minecraft.tileentity.TileEntityBrewingStand;
+import net.minecraft.tileentity.TileEntityChest;
+import net.minecraft.tileentity.TileEntityDispenser;
+import net.minecraft.tileentity.TileEntityDropper;
+import net.minecraft.tileentity.TileEntityEnderChest;
+import net.minecraft.tileentity.TileEntityFurnace;
+import net.minecraft.tileentity.TileEntityHopper;
+import net.minecraft.tileentity.TileEntityMobSpawner;
+import net.minecraft.tileentity.TileEntityNote;
+import net.minecraft.tileentity.TileEntityRecordPlayer;
+import net.minecraft.tileentity.TileEntitySign;
 import net.minecraft.util.ChunkCoordinates;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.util.IntHashMap;
@@ -47,21 +65,41 @@
 import net.minecraft.world.biome.WorldChunkManager;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.chunk.storage.AnvilChunkLoader;
 import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
 import net.minecraft.world.chunk.storage.IChunkLoader;
 import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.feature.WorldGeneratorBonusChest;
 import net.minecraft.world.storage.ISaveHandler;
 
-public class WorldServer extends World
+import net.minecraftforge.common.ChestGenHooks;
+import static net.minecraftforge.common.ChestGenHooks.*;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.ForgeEventFactory;
+import net.minecraftforge.event.world.WorldEvent;
+
+// CraftBukkit start
+import org.bukkit.WeatherType;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.craftbukkit.util.LongObjectHashMap;
+
+import org.bukkit.event.block.BlockFormEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.bukkit.event.weather.ThunderChangeEvent;
+import org.bukkit.event.weather.WeatherChangeEvent;
+
+public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
 {
+    // CraftBukkit end
+
     private final MinecraftServer mcServer;
-    private final EntityTracker theEntityTracker;
+    public EntityTracker theEntityTracker; // CraftBukkit - private final -> public
     private final PlayerManager thePlayerManager;
-    private Set pendingTickListEntriesHashSet;
-
-    /** All work to do in future ticks. */
-    private TreeSet pendingTickListEntriesTreeSet;
+    private LongObjectHashMap<Set<NextTickListEntry>> tickEntriesByChunk; // Spigot - switch to something better for chunk-wise access
+    private Set pendingTickListEntriesHashSet; // MCPC+ - vanilla compatibility
+    private TreeSet<NextTickListEntry> tickEntryQueue; // Spigot
     public ChunkProviderServer theChunkProviderServer;
 
     /** set by CommandServerSave{all,Off,On} */
@@ -88,14 +126,20 @@
      */
     private int blockEventCacheIndex;
     public static final WeightedRandomChestContent[] bonusChestContent = new WeightedRandomChestContent[] {new WeightedRandomChestContent(Item.stick.itemID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.planks.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Block.wood.blockID, 0, 1, 3, 10), new WeightedRandomChestContent(Item.axeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.axeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.pickaxeStone.itemID, 0, 1, 1, 3), new WeightedRandomChestContent(Item.pickaxeWood.itemID, 0, 1, 1, 5), new WeightedRandomChestContent(Item.appleRed.itemID, 0, 2, 3, 5), new WeightedRandomChestContent(Item.bread.itemID, 0, 2, 3, 3)};
-    private List pendingTickListEntriesThisTick = new ArrayList();
+    private List<NextTickListEntry> pendingTickEntries = new ArrayList<NextTickListEntry>(); // Spigot
+    private int nextPendingTickEntry; // Spigot
 
     /** An IntHashMap of entity IDs (integers) to their Entity objects. */
     private IntHashMap entityIdMap;
 
+    /** Stores the recently processed (lighting) chunks */
+    protected Set<ChunkCoordIntPair> doneChunks = new HashSet<ChunkCoordIntPair>();
+    public List<Teleporter> customTeleporters = new ArrayList<Teleporter>();
+
     public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, WorldSettings par5WorldSettings, Profiler par6Profiler, ILogAgent par7ILogAgent)
     {
         super(par2ISaveHandler, par3Str, par5WorldSettings, WorldProvider.getProviderForDimension(par4), par6Profiler, par7ILogAgent);
+        this.dimension = par4;
         this.mcServer = par1MinecraftServer;
         this.theEntityTracker = new EntityTracker(this);
         this.thePlayerManager = new PlayerManager(this, par1MinecraftServer.getConfigurationManager().getViewDistance());
@@ -105,14 +149,15 @@
             this.entityIdMap = new IntHashMap();
         }
 
-        if (this.pendingTickListEntriesHashSet == null)
-        {
-            this.pendingTickListEntriesHashSet = new HashSet();
-        }
-
-        if (this.pendingTickListEntriesTreeSet == null)
-        {
-            this.pendingTickListEntriesTreeSet = new TreeSet();
+        if (this.tickEntriesByChunk == null)
+        {
+            this.pendingTickListEntriesHashSet = new HashSet(); // MCPC+ - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
+        }
+
+        if (this.tickEntryQueue == null)
+        {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
         }
 
         this.worldTeleporter = new Teleporter(this);
@@ -125,9 +170,212 @@
             this.mapStorage.setData("scoreboard", scoreboardsavedata);
         }
 
-        scoreboardsavedata.func_96499_a(this.worldScoreboard);
+        if (!(this instanceof WorldServerMulti)) //Forge: We fix the global mapStorage, which causes us to share scoreboards early. So don't associate the save data with the temporary scoreboard
+        {
+            scoreboardsavedata.func_96499_a(this.worldScoreboard);
+        }
         ((ServerScoreboard)this.worldScoreboard).func_96547_a(scoreboardsavedata);
-    }
+        DimensionManager.setWorld(par4, this);
+    }
+
+    public WorldServer(MinecraftServer minecraftServer, ISaveHandler saveHandler, String par2String, WorldProvider provider, WorldSettings par4WorldSettings, Profiler theProfiler, ILogAgent worldLogAgent)
+    {
+        super(saveHandler, par2String, provider, par4WorldSettings, theProfiler, worldLogAgent);
+        this.dimension = provider.dimensionId;
+        this.pvpMode = minecraftServer.isPVPEnabled();
+        this.mcServer = minecraftServer;
+        this.theEntityTracker = null;
+        this.thePlayerManager = null;
+        this.worldTeleporter = null;
+    }
+
+    // CraftBukkit start
+    public final int dimension;
+
+    public WorldServer(MinecraftServer minecraftserver, ISaveHandler isavehandler, String s, int i, WorldSettings worldsettings, Profiler profiler, ILogAgent ilogagent, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen)
+    {
+        super(isavehandler, s, worldsettings, WorldProvider.getProviderForDimension(i), profiler, ilogagent, gen, env);
+        this.dimension = i;
+        this.pvpMode = minecraftserver.isPVPEnabled();
+        // CraftBukkit end
+        this.mcServer = minecraftserver;
+        this.theEntityTracker = new EntityTracker(this);
+        this.thePlayerManager = new PlayerManager(this, spigotConfig.viewDistance); // Spigot
+
+        if (this.entityIdMap == null)
+        {
+            this.entityIdMap = new IntHashMap();
+        }
+
+        // Spigot start
+        if (this.tickEntriesByChunk == null)
+        {
+            this.pendingTickListEntriesHashSet = new HashSet(); // MCPC+ - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
+        }
+
+        if (this.tickEntryQueue == null)
+        {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
+        }
+
+        // Spigot end
+        this.worldTeleporter = new org.bukkit.craftbukkit.CraftTravelAgent(this); // CraftBukkit
+        this.worldScoreboard = new ServerScoreboard(minecraftserver);
+        ScoreboardSaveData scoreboardsavedata = (ScoreboardSaveData)this.mapStorage.loadData(ScoreboardSaveData.class, "scoreboard");
+
+        if (scoreboardsavedata == null)
+        {
+            scoreboardsavedata = new ScoreboardSaveData();
+            this.mapStorage.setData("scoreboard", scoreboardsavedata);
+        }
+
+        if (!(this instanceof WorldServerMulti)) //Forge: We fix the global mapStorage, which causes us to share scoreboards early. So don't associate the save data with the temporary scoreboard 
+        {
+            scoreboardsavedata.func_96499_a(this.worldScoreboard);
+        }
+        ((ServerScoreboard)this.worldScoreboard).func_96547_a(scoreboardsavedata);
+        DimensionManager.setWorld(i, this);
+    }
+
+    // MCPC+ start - wrapper to get CB support
+    public WorldServer(MinecraftServer par1MinecraftServer, ISaveHandler par2ISaveHandler, String par3Str, int par4, ILogAgent ilogagent, WorldSettings par5WorldSettings, Profiler par6Profiler)
+    {
+        this(par1MinecraftServer, par2ISaveHandler, par3Str, par4, par5WorldSettings, par6Profiler, ilogagent, null, null);
+    }
+    // MCPC+ end
+
+    // CraftBukkit start
+    @Override
+
+    /**
+     * Returns the TileEntity associated with a given block in X,Y,Z coordinates, or null if no TileEntity exists
+     */
+    public TileEntity getBlockTileEntity(int i, int j, int k)
+    {
+        TileEntity result = super.getBlockTileEntity(i, j, k);
+        int type = getBlockId(i, j, k);
+
+        if (type == Block.chest.blockID)
+        {
+            if (!(result instanceof TileEntityChest))
+            {
+                // MCPC+ - allow non-vanilla tile entities on chests for Terrafirmacraft, fixes #724
+                //result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.furnaceIdle.blockID)
+        {
+            if (!(result instanceof TileEntityFurnace))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.dropper.blockID)
+        {
+            if (!(result instanceof TileEntityDropper))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.dispenser.blockID)
+        {
+            if (!(result instanceof TileEntityDispenser))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.jukebox.blockID)
+        {
+            if (!(result instanceof TileEntityRecordPlayer))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.music.blockID)
+        {
+            if (!(result instanceof TileEntityNote))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.mobSpawner.blockID)
+        {
+            if (!(result instanceof TileEntityMobSpawner))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if ((type == Block.signPost.blockID) || (type == Block.signWall.blockID))
+        {
+            if (!(result instanceof TileEntitySign))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.enderChest.blockID)
+        {
+            if (!(result instanceof TileEntityEnderChest))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.brewingStand.blockID)
+        {
+            if (!(result instanceof TileEntityBrewingStand))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.beacon.blockID)
+        {
+            if (!(result instanceof TileEntityBeacon))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+        else if (type == Block.hopperBlock.blockID)
+        {
+            if (!(result instanceof TileEntityHopper))
+            {
+                result = fixTileEntity(i, j, k, type, result);
+            }
+        }
+
+        return result;
+    }
+
+    private TileEntity fixTileEntity(int x, int y, int z, int type, TileEntity found)
+    {
+        this.getServer().getLogger().severe("Block at " + x + "," + y + "," + z + " is " + org.bukkit.Material.getMaterial(type).toString() + " but has " + found + ". "
+                                            + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.");
+
+        if (Block.blocksList[type] instanceof BlockContainer)
+        {
+            TileEntity replacement = ((BlockContainer) Block.blocksList[type]).createNewTileEntity(this);
+            replacement.worldObj = this;
+            this.setBlockTileEntity(x, y, z, replacement);
+            return replacement;
+        }
+        else
+        {
+            this.getServer().getLogger().severe("Don't know how to fix for this type... Can't do anything! :(");
+            return found;
+        }
+    }
+
+    private boolean canSpawn(int x, int z)
+    {
+        if (this.generator != null)
+        {
+            return this.generator.canSpawn(this.getWorld(), x, z);
+        }
+        else
+        {
+            return this.provider.canCoordinateBeSpawn(x, z);
+        }
+    }
+    // CraftBukkit end
 
     /**
      * Runs a single tick for the world
@@ -155,12 +403,18 @@
         }
 
         this.theProfiler.startSection("mobSpawner");
-
-        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning"))
-        {
-            this.animalSpawner.findChunksForSpawning(this, this.spawnHostileMobs, this.spawnPeacefulMobs, this.worldInfo.getWorldTotalTime() % 400L == 0L);
-        }
-
+        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
+        long time = this.worldInfo.getWorldTotalTime();
+
+        if (this.getGameRules().getGameRuleBooleanValue("doMobSpawning") && (this.spawnHostileMobs || this.spawnPeacefulMobs) && (this instanceof WorldServer && this.playerEntities.size() > 0))
+        {
+            timings.mobSpawn.startTiming(); // Spigot
+            this.animalSpawner.findChunksForSpawning(this, this.spawnHostileMobs && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.spawnPeacefulMobs && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldInfo.getWorldTotalTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming(); // Spigot
+        }
+
+        // CraftBukkit end
+        timings.doChunkUnload.startTiming(); // Spigot
         this.theProfiler.endStartSection("chunkSource");
         this.chunkProvider.unloadQueuedChunks();
         int j = this.calculateSkylightSubtracted(1.0F);
@@ -177,19 +431,42 @@
             this.worldInfo.setWorldTime(this.worldInfo.getWorldTime() + 1L);
         }
 
+        timings.doChunkUnload.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
         this.tickUpdates(false);
+        timings.doTickPending.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickTiles");
+        timings.doTickTiles.startTiming(); // Spigot
         this.tickBlocksAndAmbiance();
+        timings.doTickTiles.stopTiming(); // Spigot
         this.theProfiler.endStartSection("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
         this.thePlayerManager.updatePlayerInstances();
+        timings.doChunkMap.stopTiming(); // Spigot
         this.theProfiler.endStartSection("village");
+        timings.doVillages.startTiming(); // Spigot
         this.villageCollectionObj.tick();
         this.villageSiegeObj.tick();
+        timings.doVillages.stopTiming(); // Spigot
         this.theProfiler.endStartSection("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
         this.worldTeleporter.removeStalePortalLocations(this.getTotalWorldTime());
+        for (Teleporter tele : customTeleporters)
+        {
+            tele.removeStalePortalLocations(getTotalWorldTime());
+        }
+        timings.doPortalForcer.stopTiming(); // Spigot
         this.theProfiler.endSection();
+        timings.doSounds.startTiming(); // Spigot
         this.sendAndApplyBlockEvents();
+        timings.doSounds.stopTiming(); // Spigot
+        if (this.getWorld() != null) // MCPC+
+        {
+            timings.doChunkGC.startTiming(); // Spigot
+            this.getWorld().processChunkGC(); // CraftBukkit
+            timings.doChunkGC.stopTiming(); // Spigot
+        }
     }
 
     /**
@@ -198,6 +475,7 @@
     public SpawnListEntry spawnRandomCreature(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)
     {
         List list = this.getChunkProvider().getPossibleCreatures(par1EnumCreatureType, par2, par3, par4);
+        list = ForgeEventFactory.getPotentialSpawns(this, par1EnumCreatureType, par2, par3, par4, list);
         return list != null && !list.isEmpty() ? (SpawnListEntry)WeightedRandom.getRandomItem(this.rand, list) : null;
     }
 
@@ -213,7 +491,7 @@
         {
             EntityPlayer entityplayer = (EntityPlayer)iterator.next();
 
-            if (!entityplayer.isPlayerSleeping())
+            if (!entityplayer.isPlayerSleeping() && !entityplayer.fauxSleeping)   // CraftBukkit
             {
                 this.allPlayersSleeping = false;
                 break;
@@ -241,10 +519,26 @@
 
     private void resetRainAndThunder()
     {
-        this.worldInfo.setRainTime(0);
-        this.worldInfo.setRaining(false);
-        this.worldInfo.setThunderTime(0);
-        this.worldInfo.setThundering(false);
+        // CraftBukkit start
+        WeatherChangeEvent weather = new WeatherChangeEvent(this.getWorld(), false);
+        this.getServer().getPluginManager().callEvent(weather);
+        ThunderChangeEvent thunder = new ThunderChangeEvent(this.getWorld(), false);
+        this.getServer().getPluginManager().callEvent(thunder);
+
+        if (!weather.isCancelled())
+        {
+            this.worldInfo.setRainTime(0);
+            this.worldInfo.setRaining(false);
+        }
+
+        if (!thunder.isCancelled())
+        {
+            this.worldInfo.setThunderTime(0);
+            this.worldInfo.setThundering(false);
+        }
+
+        // CraftBukkit end
+        if (!weather.isCancelled() && !thunder.isCancelled()) provider.resetRainAndThunder(); // MCPC+
     }
 
     public boolean areAllPlayersAsleep()
@@ -252,19 +546,28 @@
         if (this.allPlayersSleeping && !this.isRemote)
         {
             Iterator iterator = this.playerEntities.iterator();
+            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
+            boolean foundActualSleepers = false;
             EntityPlayer entityplayer;
 
             do
             {
                 if (!iterator.hasNext())
                 {
-                    return true;
+                    return foundActualSleepers; // CraftBukkit
                 }
 
                 entityplayer = (EntityPlayer)iterator.next();
-            }
-            while (entityplayer.isPlayerFullyAsleep());
-
+
+                // CraftBukkit start
+                if (entityplayer.isPlayerFullyAsleep())
+                {
+                    foundActualSleepers = true;
+                }
+            }
+            while (entityplayer.isPlayerFullyAsleep() || entityplayer.fauxSleeping);
+
+            // CraftBukkit end
             return false;
         }
         else
@@ -314,15 +617,32 @@
         super.tickBlocksAndAmbiance();
         int i = 0;
         int j = 0;
-        Iterator iterator = this.activeChunkSet.iterator();
-
-        while (iterator.hasNext())
-        {
-            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair)iterator.next();
-            int k = chunkcoordintpair.chunkXPos * 16;
-            int l = chunkcoordintpair.chunkZPos * 16;
+        // CraftBukkit start
+        // Iterator iterator = this.chunkTickList.iterator();
+
+        // Spigot start
+        for (TLongShortIterator iter = activeChunkSet_CB.iterator(); iter.hasNext();)
+        {
+            iter.advance();
+            long chunkCoord = iter.key();
+            int chunkX = World.keyToX(chunkCoord);
+            int chunkZ = World.keyToZ(chunkCoord);
+            // If unloaded, or in process of being unloaded, drop it
+            if ((!this.chunkExists(chunkX, chunkZ)) || (this.theChunkProviderServer.chunksToUnload.contains(chunkX, chunkZ)))
+            {
+                activeChunkSet.remove(new ChunkCoordIntPair(chunkX, chunkZ)); // MCPC+ - vanilla compatibility
+                iter.remove();
+                continue;
+            }
+            // Spigot end
+            // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+            int k = chunkX * 16;
+            int l = chunkZ * 16;
+
             this.theProfiler.startSection("getChunk");
-            Chunk chunk = this.getChunkFromChunkCoords(chunkcoordintpair.chunkXPos, chunkcoordintpair.chunkZPos);
+            Chunk chunk = this.getChunkFromChunkCoords(chunkX, chunkZ);
+            // CraftBukkit end
+
             this.moodSoundAndLightCheck(k, l, chunk);
             this.theProfiler.endStartSection("tickChunk");
             chunk.updateSkylight();
@@ -332,14 +652,13 @@
             int k1;
             int l1;
 
-            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
+            if (provider.canDoLightning(chunk) && this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
                 i1 = this.updateLCG >> 2;
                 j1 = k + (i1 & 15);
                 k1 = l + (i1 >> 8 & 15);
                 l1 = this.getPrecipitationHeight(j1, k1);
-
                 if (this.canLightningStrikeAt(j1, l1, k1))
                 {
                     this.addWeatherEffect(new EntityLightningBolt(this, (double)j1, (double)l1, (double)k1));
@@ -349,7 +668,7 @@
             this.theProfiler.endStartSection("iceandsnow");
             int i2;
 
-            if (this.rand.nextInt(16) == 0)
+            if (provider.canDoRainSnowIce(chunk) && this.rand.nextInt(16) == 0)
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
                 i1 = this.updateLCG >> 2;
@@ -359,12 +678,32 @@
 
                 if (this.isBlockFreezableNaturally(j1 + k, l1 - 1, k1 + l))
                 {
-                    this.setBlock(j1 + k, l1 - 1, k1 + l, Block.ice.blockID);
+                    // CraftBukkit start
+                    BlockState blockState = this.getWorld().getBlockAt(j1 + k, l1 - 1, k1 + l).getState();
+                    blockState.setTypeId(Block.ice.blockID);
+                    BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                    this.getServer().getPluginManager().callEvent(iceBlockForm);
+                    if (!iceBlockForm.isCancelled())
+                    {
+                        blockState.update(true);
+                    }
+                    // CraftBukkit end
                 }
 
                 if (this.isRaining() && this.canSnowAt(j1 + k, l1, k1 + l))
                 {
-                    this.setBlock(j1 + k, l1, k1 + l, Block.snow.blockID);
+                    // CraftBukkit start
+                    BlockState blockState = this.getWorld().getBlockAt(j1 + k, l1, k1 + l).getState();
+                    blockState.setTypeId(Block.snow.blockID);
+
+                    BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                    this.getServer().getPluginManager().callEvent(snow);
+
+                    if (!snow.isCancelled())
+                    {
+                        blockState.update(true);
+                    }
+                    // CraftBukkit end
                 }
 
                 if (this.isRaining())
@@ -374,7 +713,6 @@
                     if (biomegenbase.canSpawnLightningBolt())
                     {
                         i2 = this.getBlockId(j1 + k, l1 - 1, k1 + l);
-
                         if (i2 != 0)
                         {
                             Block.blocksList[i2].fillWithRain(this, j1 + k, l1 - 1, k1 + l);
@@ -385,6 +723,7 @@
 
             this.theProfiler.endStartSection("tickTiles");
             ExtendedBlockStorage[] aextendedblockstorage = chunk.getBlockStorageArray();
+
             j1 = aextendedblockstorage.length;
 
             for (k1 = 0; k1 < j1; ++k1)
@@ -401,12 +740,14 @@
                         int l2 = i2 >> 8 & 15;
                         int i3 = i2 >> 16 & 15;
                         int j3 = extendedblockstorage.getExtBlockID(k2, i3, l2);
+
                         ++j;
                         Block block = Block.blocksList[j3];
 
                         if (block != null && block.getTickRandomly())
                         {
                             ++i;
+                            this.growthOdds = (iter.value() < 1) ? this.modifiedOdds : 100; // Spigot - grow fast if no players are in this chunk (value = player count)
                             block.updateTick(this, k2 + k, i3 + extendedblockstorage.getYLocation(), l2 + l, this.rand);
                         }
                     }
@@ -422,21 +763,37 @@
      */
     public boolean isBlockTickScheduledThisTick(int par1, int par2, int par3, int par4)
     {
+        // Spigot start
+        int te_cnt = this.pendingTickEntries.size();
+
+        for (int idx = this.nextPendingTickEntry; idx < te_cnt; idx++)
+        {
+            NextTickListEntry ent = this.pendingTickEntries.get(idx);
+
+            if ((ent.xCoord == par1) && (ent.yCoord == par2) && (ent.zCoord == par3) && Block.isAssociatedBlockID(ent.blockID, par4))
+            {
+                return true;
+            }
+        }
+
+        return false;
+        // Spigot end
+    }
+
+    /**
+     * Schedules a tick to a block with a delay (Most commonly the tick rate)
+     */
+    public void scheduleBlockUpdate(int par1, int par2, int par3, int par4, int par5)
+    {
+        this.scheduleBlockUpdateWithPriority(par1, par2, par3, par4, par5, 0);
+    }
+
+    public void scheduleBlockUpdateWithPriority(int par1, int par2, int par3, int par4, int par5, int par6)
+    {
         NextTickListEntry nextticklistentry = new NextTickListEntry(par1, par2, par3, par4);
-        return this.pendingTickListEntriesThisTick.contains(nextticklistentry);
-    }
-
-    /**
-     * Schedules a tick to a block with a delay (Most commonly the tick rate)
-     */
-    public void scheduleBlockUpdate(int par1, int par2, int par3, int par4, int par5)
-    {
-        this.scheduleBlockUpdateWithPriority(par1, par2, par3, par4, par5, 0);
-    }
-
-    public void scheduleBlockUpdateWithPriority(int par1, int par2, int par3, int par4, int par5, int par6)
-    {
-        NextTickListEntry nextticklistentry = new NextTickListEntry(par1, par2, par3, par4);
+        //Keeping here as a note for future when it may be restored.
+        //boolean isForced = getPersistentChunks().containsKey(new ChunkCoordIntPair(nextticklistentry.xCoord >> 4, nextticklistentry.zCoord >> 4));
+        //byte b0 = isForced ? 0 : 8;
         byte b0 = 0;
 
         if (this.scheduledUpdatesAreImmediate && par4 > 0)
@@ -469,11 +826,9 @@
                 nextticklistentry.setPriority(par6);
             }
 
-            if (!this.pendingTickListEntriesHashSet.contains(nextticklistentry))
-            {
-                this.pendingTickListEntriesHashSet.add(nextticklistentry);
-                this.pendingTickListEntriesTreeSet.add(nextticklistentry);
-            }
+            // Spigot start
+            addNextTickIfNeeded(nextticklistentry);
+            // Spigot end
         }
     }
 
@@ -490,19 +845,18 @@
             nextticklistentry.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
         }
 
-        if (!this.pendingTickListEntriesHashSet.contains(nextticklistentry))
-        {
-            this.pendingTickListEntriesHashSet.add(nextticklistentry);
-            this.pendingTickListEntriesTreeSet.add(nextticklistentry);
-        }
+        // Spigot start
+        addNextTickIfNeeded(nextticklistentry);
+        // Spigot end
     }
 
     /**
      * Updates (and cleans up) entities and tile entities
      */
+    /* MCPC+ tick entities even if nobody is on and no persistent chunks exist
     public void updateEntities()
     {
-        if (this.playerEntities.isEmpty())
+        if (this.playerEntities.isEmpty() && getPersistentChunks().isEmpty()) // MCPC+ Use Forge logic here
         {
             if (this.updateEntityTick++ >= 1200)
             {
@@ -516,6 +870,7 @@
 
         super.updateEntities();
     }
+    */
 
     /**
      * Resets the updateEntityTick field to 0
@@ -530,17 +885,24 @@
      */
     public boolean tickUpdates(boolean par1)
     {
-        int i = this.pendingTickListEntriesTreeSet.size();
-
-        if (i != this.pendingTickListEntriesHashSet.size())
-        {
-            throw new IllegalStateException("TickNextTick list out of synch");
-        }
-        else
-        {
+        // Spigot start
+        int i = this.tickEntryQueue.size();
+        this.nextPendingTickEntry = 0;
+        {
+            // Spigot end
             if (i > 1000)
             {
-                i = 1000;
+                // CraftBukkit start - If the server has too much to process over time, try to alleviate that
+                if (i > 20 * 1000)
+                {
+                    i = i / 20;
+                }
+                else
+                {
+                    i = 1000;
+                }
+
+                // CraftBukkit end
             }
 
             this.theProfiler.startSection("cleaning");
@@ -548,26 +910,28 @@
 
             for (int j = 0; j < i; ++j)
             {
-                nextticklistentry = (NextTickListEntry)this.pendingTickListEntriesTreeSet.first();
+                nextticklistentry = (NextTickListEntry) this.tickEntryQueue.first(); // Spigot
 
                 if (!par1 && nextticklistentry.scheduledTime > this.worldInfo.getWorldTotalTime())
                 {
                     break;
                 }
 
-                this.pendingTickListEntriesTreeSet.remove(nextticklistentry);
-                this.pendingTickListEntriesHashSet.remove(nextticklistentry);
-                this.pendingTickListEntriesThisTick.add(nextticklistentry);
+                // Spigot start
+                this.removeNextTickIfNeeded(nextticklistentry);
+                this.pendingTickEntries.add(nextticklistentry);
+                // Spigot end
             }
 
             this.theProfiler.endSection();
             this.theProfiler.startSection("ticking");
-            Iterator iterator = this.pendingTickListEntriesThisTick.iterator();
-
-            while (iterator.hasNext())
-            {
-                nextticklistentry = (NextTickListEntry)iterator.next();
-                iterator.remove();
+
+            // Spigot start
+            for (int j = 0, te_cnt = this.pendingTickEntries.size(); j < te_cnt; j++)
+            {
+                nextticklistentry = pendingTickEntries.get(j);
+                this.nextPendingTickEntry = j + 1; // treat this as dequeued
+                // Spigot end
                 byte b0 = 0;
 
                 if (this.checkChunksExist(nextticklistentry.xCoord - b0, nextticklistentry.yCoord - b0, nextticklistentry.zCoord - b0, nextticklistentry.xCoord + b0, nextticklistentry.yCoord + b0, nextticklistentry.zCoord + b0))
@@ -607,61 +971,19 @@
             }
 
             this.theProfiler.endSection();
-            this.pendingTickListEntriesThisTick.clear();
-            return !this.pendingTickListEntriesTreeSet.isEmpty();
+            // Spigot start
+            this.pendingTickEntries.clear();
+            this.nextPendingTickEntry = 0;
+            return !this.tickEntryQueue.isEmpty();
+            // Spigot end
         }
     }
 
     public List getPendingBlockUpdates(Chunk par1Chunk, boolean par2)
     {
-        ArrayList arraylist = null;
-        ChunkCoordIntPair chunkcoordintpair = par1Chunk.getChunkCoordIntPair();
-        int i = (chunkcoordintpair.chunkXPos << 4) - 2;
-        int j = i + 16 + 2;
-        int k = (chunkcoordintpair.chunkZPos << 4) - 2;
-        int l = k + 16 + 2;
-
-        for (int i1 = 0; i1 < 2; ++i1)
-        {
-            Iterator iterator;
-
-            if (i1 == 0)
-            {
-                iterator = this.pendingTickListEntriesTreeSet.iterator();
-            }
-            else
-            {
-                iterator = this.pendingTickListEntriesThisTick.iterator();
-
-                if (!this.pendingTickListEntriesThisTick.isEmpty())
-                {
-                    System.out.println(this.pendingTickListEntriesThisTick.size());
-                }
-            }
-
-            while (iterator.hasNext())
-            {
-                NextTickListEntry nextticklistentry = (NextTickListEntry)iterator.next();
-
-                if (nextticklistentry.xCoord >= i && nextticklistentry.xCoord < j && nextticklistentry.zCoord >= k && nextticklistentry.zCoord < l)
-                {
-                    if (par2)
-                    {
-                        this.pendingTickListEntriesHashSet.remove(nextticklistentry);
-                        iterator.remove();
-                    }
-
-                    if (arraylist == null)
-                    {
-                        arraylist = new ArrayList();
-                    }
-
-                    arraylist.add(nextticklistentry);
-                }
-            }
-        }
-
-        return arraylist;
+        // Spigot start
+        return this.getNextTickEntriesForChunk(par1Chunk, par2);
+        // Spigot end
     }
 
     /**
@@ -670,17 +992,38 @@
      */
     public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
     {
-        if (!this.mcServer.getCanSpawnAnimals() && (par1Entity instanceof EntityAnimal || par1Entity instanceof EntityWaterMob))
+        /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
+        if (!this.server.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
+            entity.die();
+        }
+        // CraftBukkit end */
+        if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
         {
             par1Entity.setDead();
         }
 
-        if (!this.mcServer.getCanSpawnNPCs() && par1Entity instanceof INpc)
-        {
-            par1Entity.setDead();
-        }
-
-        super.updateEntityWithOptionalForce(par1Entity, par2);
+        if (!(par1Entity.riddenByEntity instanceof EntityPlayer))
+        {
+            super.updateEntityWithOptionalForce(par1Entity, par2);
+        }
+    }
+
+    /**
+     * direct call to super.updateEntityWithOptionalForce
+     */
+    public void uncheckedUpdateEntity(Entity par1Entity, boolean par2)
+    {
+        try
+        {
+            super.updateEntityWithOptionalForce(par1Entity, par2);
+        }
+        catch (Throwable throwable)
+        {
+            CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Forcefully ticking entity");
+            CrashReportCategory crashreportcategory = crashreport.makeCategory("Entity being force ticked");
+            par1Entity.addEntityCrashInfo(crashreportcategory);
+            throw new ReportedException(crashreport);
+        }
     }
 
     /**
@@ -689,7 +1032,36 @@
     protected IChunkProvider createChunkProvider()
     {
         IChunkLoader ichunkloader = this.saveHandler.getChunkLoader(this.provider);
-        this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, this.provider.createChunkGenerator());
+        // MCPC+ start - if provider is vanilla, proceed to create a bukkit compatible chunk generator
+        if (this.provider.getClass().toString().length() <= 3 || this.provider.getClass().toString().contains("net.minecraft"))
+        {
+            // CraftBukkit start
+            org.bukkit.craftbukkit.generator.InternalChunkGenerator gen;
+    
+            if (this.generator != null)
+            {
+                gen = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, this.getSeed(), this.generator);
+            }
+            else if (this.provider instanceof WorldProviderHell)
+            {
+                gen = new org.bukkit.craftbukkit.generator.NetherChunkGenerator(this, this.getSeed());
+            }
+            else if (this.provider instanceof WorldProviderEnd)
+            {
+                gen = new org.bukkit.craftbukkit.generator.SkyLandsChunkGenerator(this, this.getSeed());
+            }
+            else
+            {
+                gen = new org.bukkit.craftbukkit.generator.NormalChunkGenerator(this, this.getSeed());
+            }
+            this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, gen);
+            // CraftBukkit end
+        }
+        else // custom provider, load normally for forge compatibility
+        {
+            this.theChunkProviderServer = new ChunkProviderServer(this, ichunkloader, this.provider.createChunkGenerator());
+        }
+        // MCPC+ end
         return this.theChunkProviderServer;
     }
 
@@ -700,16 +1072,31 @@
     {
         ArrayList arraylist = new ArrayList();
 
-        for (int k1 = 0; k1 < this.loadedTileEntityList.size(); ++k1)
-        {
-            TileEntity tileentity = (TileEntity)this.loadedTileEntityList.get(k1);
-
-            if (tileentity.xCoord >= par1 && tileentity.yCoord >= par2 && tileentity.zCoord >= par3 && tileentity.xCoord < par4 && tileentity.yCoord < par5 && tileentity.zCoord < par6)
-            {
-                arraylist.add(tileentity);
-            }
-        }
-
+        // CraftBukkit start - Get tile entities from chunks instead of world
+        for (int chunkX = (par1 >> 4); chunkX <= ((par4 - 1) >> 4); chunkX++)
+        {
+            for (int chunkZ = (par3 >> 4); chunkZ <= ((par6 - 1) >> 4); chunkZ++)
+            {
+                Chunk chunk = getChunkFromChunkCoords(chunkX, chunkZ);
+
+                if (chunk == null)
+                {
+                    continue;
+                }
+
+                for (Object te : chunk.chunkTileEntityMap.values())
+                {
+                    TileEntity tileentity = (TileEntity) te;
+
+                    if ((tileentity.xCoord >= par1) && (tileentity.yCoord >= par2) && (tileentity.zCoord >= par3) && (tileentity.xCoord < par4) && (tileentity.yCoord < par5) && (tileentity.zCoord < par6))
+                    {
+                        arraylist.add(tileentity);
+                    }
+                }
+            }
+        }
+
+        // CraftBukkit end
         return arraylist;
     }
 
@@ -718,6 +1105,11 @@
      */
     public boolean canMineBlock(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
     {
+        return super.canMineBlock(par1EntityPlayer, par2, par3, par4);
+    }
+
+    public boolean canMineBlockBody(EntityPlayer par1EntityPlayer, int par2, int par3, int par4)
+    {
         return !this.mcServer.isBlockProtected(this, par2, par3, par4, par1EntityPlayer);
     }
 
@@ -728,16 +1120,19 @@
             this.entityIdMap = new IntHashMap();
         }
 
-        if (this.pendingTickListEntriesHashSet == null)
-        {
-            this.pendingTickListEntriesHashSet = new HashSet();
-        }
-
-        if (this.pendingTickListEntriesTreeSet == null)
-        {
-            this.pendingTickListEntriesTreeSet = new TreeSet();
-        }
-
+        // Spigot start
+        if (this.tickEntriesByChunk == null)
+        {
+            this.pendingTickListEntriesHashSet = new HashSet(); // MCPC+ - vanilla compatibility
+            this.tickEntriesByChunk = new LongObjectHashMap<Set<NextTickListEntry>>();
+        }
+
+        if (this.tickEntryQueue == null)
+        {
+            this.tickEntryQueue = new TreeSet<NextTickListEntry>();
+        }
+
+        // Spigot end
         this.createSpawnPosition(par1WorldSettings);
         super.initialize(par1WorldSettings);
     }
@@ -762,6 +1157,29 @@
             int j = this.provider.getAverageGroundLevel();
             int k = 0;
 
+            // CraftBukkit start
+            if (this.generator != null)
+            {
+                Random rand = new Random(this.getSeed());
+                org.bukkit.Location spawn = this.generator.getFixedSpawnLocation(((WorldServer) this).getWorld(), rand);
+
+                if (spawn != null)
+                {
+                    if (spawn.getWorld() != ((WorldServer) this).getWorld())
+                    {
+                        throw new IllegalStateException("Cannot set spawn point for " + this.worldInfo.getWorldName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                    }
+                    else
+                    {
+                        this.worldInfo.setSpawnPosition(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ());
+                        this.findingSpawnPoint = false;
+                        return;
+                    }
+                }
+            }
+
+            // CraftBukkit end
+
             if (chunkposition != null)
             {
                 i = chunkposition.x;
@@ -774,7 +1192,7 @@
 
             int l = 0;
 
-            while (!this.provider.canCoordinateBeSpawn(i, k))
+            while (!this.canSpawn(i, k))   // CraftBukkit - use our own canSpawn
             {
                 i += random.nextInt(64) - random.nextInt(64);
                 k += random.nextInt(64) - random.nextInt(64);
@@ -801,7 +1219,7 @@
      */
     protected void createBonusChest()
     {
-        WorldGeneratorBonusChest worldgeneratorbonuschest = new WorldGeneratorBonusChest(bonusChestContent, 10);
+        WorldGeneratorBonusChest worldgeneratorbonuschest = new WorldGeneratorBonusChest(ChestGenHooks.getItems(BONUS_CHEST, rand), ChestGenHooks.getCount(BONUS_CHEST, rand));
 
         for (int i = 0; i < 10; ++i)
         {
@@ -844,6 +1262,7 @@
             }
 
             this.chunkProvider.saveChunks(par1, par2IProgressUpdate);
+            MinecraftForge.EVENT_BUS.post(new WorldEvent.Save(this));
         }
     }
 
@@ -866,6 +1285,7 @@
         this.checkSessionLock();
         this.saveHandler.saveWorldInfoWithPlayer(this.worldInfo, this.mcServer.getConfigurationManager().getHostPlayerData());
         this.mapStorage.saveAllData();
+        this.perWorldStorage.saveAllData();
     }
 
     protected void onEntityAdded(Entity par1Entity)
@@ -911,9 +1331,23 @@
      */
     public boolean addWeatherEffect(Entity par1Entity)
     {
+        // MCPC+ start - vanilla compatibility
+        if (par1Entity instanceof net.minecraft.entity.effect.EntityLightningBolt) 
+        {
+            // CraftBukkit start
+            LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) par1Entity.getBukkitEntity());
+            this.getServer().getPluginManager().callEvent(lightning);
+    
+            if (lightning.isCancelled())
+            {
+                return false;
+            }
+        } 
+        // MCPC+ end
         if (super.addWeatherEffect(par1Entity))
         {
-            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.provider.dimensionId, new Packet71Weather(par1Entity));
+            this.mcServer.getConfigurationManager().sendToAllNear(par1Entity.posX, par1Entity.posY, par1Entity.posZ, 512.0D, this.dimension, new Packet71Weather(par1Entity));
+            // CraftBukkit end
             return true;
         }
         else
@@ -936,11 +1370,21 @@
      */
     public Explosion newExplosion(Entity par1Entity, double par2, double par4, double par6, float par8, boolean par9, boolean par10)
     {
-        Explosion explosion = new Explosion(this, par1Entity, par2, par4, par6, par8);
-        explosion.isFlaming = par9;
-        explosion.isSmoking = par10;
-        explosion.doExplosionA();
-        explosion.doExplosionB(false);
+        // CraftBukkit start
+        Explosion explosion = super.newExplosion(par1Entity, par2, par4, par6, par8, par9, par10);
+
+        if (explosion.wasCanceled)
+        {
+            return explosion;
+        }
+
+        /* Remove
+        explosion.a = flag;
+        explosion.b = flag1;
+        explosion.a();
+        explosion.a(false);
+        */
+        // CraftBukkit end - TODO: Check if explosions are still properly implemented
 
         if (!par10)
         {
@@ -1037,14 +1481,16 @@
 
         if (flag != this.isRaining())
         {
-            if (flag)
-            {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new Packet70GameEvent(2, 0));
-            }
-            else
-            {
-                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new Packet70GameEvent(1, 0));
-            }
+            // CraftBukkit start - Only send weather packets to those affected
+            for (int i = 0; i < this.playerEntities.size(); ++i)
+            {
+                if (((EntityPlayerMP) this.playerEntities.get(i)).worldObj == this)
+                {
+                    ((EntityPlayerMP) this.playerEntities.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                }
+            }
+
+            // CraftBukkit end
         }
     }
 
@@ -1073,4 +1519,123 @@
     {
         return this.worldTeleporter;
     }
+
+    public File getChunkSaveLocation()
+    {
+        return ((AnvilChunkLoader)theChunkProviderServer.currentChunkLoader).chunkSaveLocation;
+    }
+    
+    // CraftBukkit start - Compatibility methods for BlockChangeDelegate
+    public boolean setRawTypeId(int x, int y, int z, int typeId)
+    {
+        return this.setBlock(x, y, z, typeId, 0, 4);
+    }
+
+    public boolean setRawTypeIdAndData(int x, int y, int z, int typeId, int data)
+    {
+        return this.setBlock(x, y, z, typeId, data, 4);
+    }
+
+    public boolean setTypeId(int x, int y, int z, int typeId)
+    {
+        return this.setBlock(x, y, z, typeId, 0, 3);
+    }
+
+    public boolean setTypeIdAndData(int x, int y, int z, int typeId, int data)
+    {
+        return this.setBlock(x, y, z, typeId, data, 3);
+    }
+    // CraftBukkit end
+    // Spigot start
+    private void addNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+
+        if (chunkset == null)
+        {
+            chunkset = new HashSet<NextTickListEntry>();
+            this.tickEntriesByChunk.put(coord, chunkset);
+        }
+        else if (chunkset.contains(ent))
+        {
+            return;
+        }
+
+        chunkset.add(ent);
+        this.tickEntryQueue.add(ent);
+        this.pendingTickListEntriesHashSet.add(ent); // MCPC+ - vanilla compatibility
+    }
+
+    private void removeNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+
+        if (chunkset != null)
+        {
+            chunkset.remove(ent);
+
+            if (chunkset.isEmpty())
+            {
+                this.tickEntriesByChunk.remove(coord);
+            }
+        }
+
+        this.tickEntryQueue.remove(ent);
+        this.pendingTickListEntriesHashSet.remove(ent); // MCPC+ - vanilla compatibility
+    }
+
+    private List<NextTickListEntry> getNextTickEntriesForChunk(Chunk chunk, boolean remove)
+    {
+        long coord = LongHash.toLong(chunk.xPosition, chunk.zPosition);
+        Set<NextTickListEntry> chunkset = this.tickEntriesByChunk.get(coord);
+        List<NextTickListEntry> list = null;
+
+        if (chunkset != null)
+        {
+            list = new ArrayList<NextTickListEntry>(chunkset);
+
+            if (remove)
+            {
+                this.tickEntriesByChunk.remove(coord);
+                this.tickEntryQueue.removeAll(list);
+                chunkset.clear();
+            }
+        }
+
+        // See if any on list of ticks being processed now
+        if (this.nextPendingTickEntry < this.pendingTickEntries.size())
+        {
+            int xmin = (chunk.xPosition << 4);
+            int xmax = xmin + 16;
+            int zmin = (chunk.zPosition << 4);
+            int zmax = zmin + 16;
+            int te_cnt = this.pendingTickEntries.size();
+
+            for (int i = this.nextPendingTickEntry; i < te_cnt; i++)
+            {
+                NextTickListEntry ent = this.pendingTickEntries.get(i);
+
+                if ((ent.xCoord >= xmin) && (ent.xCoord < xmax) && (ent.zCoord >= zmin) && (ent.zCoord < zmax))
+                {
+                    if (list == null)
+                    {
+                        list = new ArrayList<NextTickListEntry>();
+                    }
+
+                    list.add(ent);
+                }
+            }
+        }
+
+        return list;
+    }
+
+    public boolean isEmpty(int a, int b, int c){
+        return isAirBlock(a, b, c);
+    }
+    public int getTypeId(int a, int b, int c){
+        return getBlockId(a, b, c);
+    }
 }
