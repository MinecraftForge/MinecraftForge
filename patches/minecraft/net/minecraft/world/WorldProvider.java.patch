--- ../src-base/minecraft/net/minecraft/world/WorldProvider.java
+++ ../src-work/minecraft/net/minecraft/world/WorldProvider.java
@@ -55,26 +55,12 @@
     protected void func_76572_b()
     {
         this.field_191067_f = true;
-        WorldType worldtype = this.field_76579_a.func_72912_H().func_76067_t();
-
-        if (worldtype == WorldType.field_77138_c)
-        {
-            FlatGeneratorInfo flatgeneratorinfo = FlatGeneratorInfo.func_82651_a(this.field_76579_a.func_72912_H().func_82571_y());
-            this.field_76578_c = new BiomeProviderSingle(Biome.func_180276_a(flatgeneratorinfo.func_82648_a(), Biomes.field_180279_ad));
-        }
-        else if (worldtype == WorldType.field_180272_g)
-        {
-            this.field_76578_c = new BiomeProviderSingle(Biomes.field_76772_c);
-        }
-        else
-        {
-            this.field_76578_c = new BiomeProvider(this.field_76579_a.func_72912_H());
-        }
+        this.field_76578_c = field_76577_b.getBiomeProvider(field_76579_a);
     }
 
     public IChunkGenerator func_186060_c()
     {
-        return (IChunkGenerator)(this.field_76577_b == WorldType.field_77138_c ? new ChunkProviderFlat(this.field_76579_a, this.field_76579_a.func_72905_C(), this.field_76579_a.func_72912_H().func_76089_r(), this.field_82913_c) : (this.field_76577_b == WorldType.field_180272_g ? new ChunkProviderDebug(this.field_76579_a) : (this.field_76577_b == WorldType.field_180271_f ? new ChunkProviderOverworld(this.field_76579_a, this.field_76579_a.func_72905_C(), this.field_76579_a.func_72912_H().func_76089_r(), this.field_82913_c) : new ChunkProviderOverworld(this.field_76579_a, this.field_76579_a.func_72905_C(), this.field_76579_a.func_72912_H().func_76089_r(), this.field_82913_c))));
+        return field_76577_b.getChunkGenerator(field_76579_a, field_82913_c);
     }
 
     public boolean func_76566_a(int p_76566_1_, int p_76566_2_)
@@ -160,7 +146,7 @@
     @SideOnly(Side.CLIENT)
     public float func_76571_f()
     {
-        return 128.0F;
+        return this.field_76577_b.getCloudHeight();
     }
 
     @SideOnly(Side.CLIENT)
@@ -177,13 +163,13 @@
 
     public int func_76557_i()
     {
-        return this.field_76577_b == WorldType.field_77138_c ? 4 : this.field_76579_a.func_181545_F() + 1;
+        return this.field_76577_b.getMinimumSpawnHeight(this.field_76579_a);
     }
 
     @SideOnly(Side.CLIENT)
     public double func_76565_k()
     {
-        return this.field_76577_b == WorldType.field_77138_c ? 1.0D : 0.03125D;
+        return this.field_76577_b.voidFadeMagnitude();
     }
 
     @SideOnly(Side.CLIENT)
@@ -222,6 +208,303 @@
         return new WorldBorder();
     }
 
+    /*======================================= Forge Start =========================================*/
+    private net.minecraftforge.client.IRenderHandler skyRenderer = null;
+    private net.minecraftforge.client.IRenderHandler cloudRenderer = null;
+    private net.minecraftforge.client.IRenderHandler weatherRenderer = null;
+    private int dimensionId;
+
+    /**
+     * Sets the providers current dimension ID, used in default getSaveFolder()
+     * Added to allow default providers to be registered for multiple dimensions.
+     * This is to denote the exact dimension ID opposed to the 'type' in WorldType
+     *
+     * @param dim Dimension ID
+     */
+    public void setDimension(int dim)
+    {
+        this.dimensionId = dim;
+    }
+    public int getDimension()
+    {
+        return this.dimensionId;
+    }
+
+    /**
+     * Returns the sub-folder of the world folder that this WorldProvider saves to.
+     * EXA: DIM1, DIM-1
+     * @return The sub-folder name to save this world's chunks to.
+     */
+    public String getSaveFolder()
+    {
+        return (dimensionId == 0 ? null : "DIM" + dimensionId);
+    }
+
+    /**
+     * The dimensions movement factor. Relative to normal overworld.
+     * It is applied to the players position when they transfer dimensions.
+     * Exa: Nether movement is 8.0
+     * @return The movement factor
+     */
+    public double getMovementFactor()
+    {
+        if (this instanceof WorldProviderHell)
+        {
+            return 8.0;
+        }
+        return 1.0;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public net.minecraftforge.client.IRenderHandler getSkyRenderer()
+    {
+        return this.skyRenderer;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void setSkyRenderer(net.minecraftforge.client.IRenderHandler skyRenderer)
+    {
+        this.skyRenderer = skyRenderer;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public net.minecraftforge.client.IRenderHandler getCloudRenderer()
+    {
+        return cloudRenderer;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void setCloudRenderer(net.minecraftforge.client.IRenderHandler renderer)
+    {
+        cloudRenderer = renderer;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public net.minecraftforge.client.IRenderHandler getWeatherRenderer()
+    {
+        return weatherRenderer;
+    }
+
+    @SideOnly(Side.CLIENT)
+    public void setWeatherRenderer(net.minecraftforge.client.IRenderHandler renderer)
+    {
+        weatherRenderer = renderer;
+    }
+
+    public BlockPos getRandomizedSpawnPoint()
+    {
+        BlockPos ret = this.field_76579_a.func_175694_M();
+
+        boolean isAdventure = field_76579_a.func_72912_H().func_76077_q() == GameType.ADVENTURE;
+        int spawnFuzz = this.field_76579_a instanceof WorldServer ? field_76577_b.getSpawnFuzz((WorldServer)this.field_76579_a, this.field_76579_a.func_73046_m()) : 1;
+        int border = MathHelper.func_76128_c(field_76579_a.func_175723_af().func_177729_b(ret.func_177958_n(), ret.func_177952_p()));
+        if (border < spawnFuzz) spawnFuzz = border;
+
+        if (!func_177495_o() && !isAdventure && spawnFuzz != 0)
+        {
+            if (spawnFuzz < 2) spawnFuzz = 2;
+            int spawnFuzzHalf = spawnFuzz / 2;
+            ret = field_76579_a.func_175672_r(ret.func_177982_a(field_76579_a.field_73012_v.nextInt(spawnFuzzHalf) - spawnFuzz, 0, field_76579_a.field_73012_v.nextInt(spawnFuzzHalf) - spawnFuzz));
+        }
+
+        return ret;
+    }
+    /**
+     * Determine if the cursor on the map should 'spin' when rendered, like it does for the player in the nether.
+     *
+     * @param entity The entity holding the map, playername, or frame-ENTITYID
+     * @param x X Position
+     * @param y Y Position
+     * @param z Z Position
+     * @return True to 'spin' the cursor
+     */
+    public boolean shouldMapSpin(String entity, double x, double y, double z)
+    {
+        return dimensionId < 0;
+    }
+
+    /**
+     * Determines the dimension the player will be respawned in, typically this brings them back to the overworld.
+     *
+     * @param player The player that is respawning
+     * @return The dimension to respawn the player in
+     */
+    public int getRespawnDimension(net.minecraft.entity.player.EntityPlayerMP player)
+    {
+        return 0;
+    }
+
+    /**
+     * Called from {@link World#initCapabilities()}, to gather capabilities for this world.
+     * It's safe to access world here since this is called after world is registered.
+     *
+     * On server, called directly after mapStorage and world data such as Scoreboard and VillageCollection are initialized.
+     * On client, called when world is constructed, just before world load event is called.
+     * Note that this method is always called before the world load event.
+     * @return initial holder for capabilities on the world
+     */
+    public net.minecraftforge.common.capabilities.ICapabilityProvider initCapabilities() {
+        return null;
+    }
+    /*======================================= Start Moved From World =========================================*/
+
+    public Biome getBiomeForCoords(BlockPos pos)
+    {
+        return field_76579_a.getBiomeForCoordsBody(pos);
+    }
+
+    public boolean isDaytime()
+    {
+        return field_76579_a.func_175657_ab() < 4;
+    }
+
+    /**
+     * The current sun brightness factor for this dimension.
+     * 0.0f means no light at all, and 1.0f means maximum sunlight.
+     * This will be used for the "calculateSkylightSubtracted"
+     * which is for Sky light value calculation.
+     *
+     * @return The current brightness factor
+     * */
+    public float getSunBrightnessFactor(float par1)
+    {
+        return field_76579_a.getSunBrightnessFactor(par1);
+    }
+
+    /**
+     * Calculates the current moon phase factor.
+     * This factor is effective for slimes.
+     * (This method do not affect the moon rendering)
+     * */
+    public float getCurrentMoonPhaseFactor()
+    {
+        return field_76579_a.getCurrentMoonPhaseFactorBody();
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3d getSkyColor(net.minecraft.entity.Entity cameraEntity, float partialTicks)
+    {
+        return field_76579_a.getSkyColorBody(cameraEntity, partialTicks);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public Vec3d getCloudColor(float partialTicks)
+    {
+        return field_76579_a.getCloudColorBody(partialTicks);
+    }
+
+    /**
+     * Gets the Sun Brightness for rendering sky.
+     * */
+    @SideOnly(Side.CLIENT)
+    public float getSunBrightness(float par1)
+    {
+        return field_76579_a.getSunBrightnessBody(par1);
+    }
+
+    /**
+     * Gets the Star Brightness for rendering sky.
+     * */
+    @SideOnly(Side.CLIENT)
+    public float getStarBrightness(float par1)
+    {
+        return field_76579_a.getStarBrightnessBody(par1);
+    }
+
+    public void setAllowedSpawnTypes(boolean allowHostile, boolean allowPeaceful)
+    {
+        field_76579_a.field_72985_G = allowHostile;
+        field_76579_a.field_72992_H = allowPeaceful;
+    }
+
+    public void calculateInitialWeather()
+    {
+        field_76579_a.calculateInitialWeatherBody();
+    }
+
+    public void updateWeather()
+    {
+        field_76579_a.updateWeatherBody();
+    }
+
+    public boolean canBlockFreeze(BlockPos pos, boolean byWater)
+    {
+        return field_76579_a.canBlockFreezeBody(pos, byWater);
+    }
+
+    public boolean canSnowAt(BlockPos pos, boolean checkLight)
+    {
+        return field_76579_a.canSnowAtBody(pos, checkLight);
+    }
+    public void setWorldTime(long time)
+    {
+        field_76579_a.field_72986_A.func_76068_b(time);
+    }
+
+    public long getSeed()
+    {
+        return field_76579_a.field_72986_A.func_76063_b();
+    }
+
+    public long getWorldTime()
+    {
+        return field_76579_a.field_72986_A.func_76073_f();
+    }
+
+    public BlockPos getSpawnPoint()
+    {
+        net.minecraft.world.storage.WorldInfo info = field_76579_a.field_72986_A;
+        return new BlockPos(info.func_76079_c(), info.func_76075_d(), info.func_76074_e());
+    }
+
+    public void setSpawnPoint(BlockPos pos)
+    {
+        field_76579_a.field_72986_A.func_176143_a(pos);
+    }
+
+    public boolean canMineBlock(net.minecraft.entity.player.EntityPlayer player, BlockPos pos)
+    {
+        return field_76579_a.canMineBlockBody(player, pos);
+    }
+
+    public boolean isBlockHighHumidity(BlockPos pos)
+    {
+        return field_76579_a.func_180494_b(pos).func_76736_e();
+    }
+
+    public int getHeight()
+    {
+        return 256;
+    }
+
+    public int getActualHeight()
+    {
+        return field_76576_e ? 128 : 256;
+    }
+
+    public double getHorizon()
+    {
+        return field_76579_a.field_72986_A.func_76067_t().getHorizon(field_76579_a);
+    }
+
+    public void resetRainAndThunder()
+    {
+        field_76579_a.field_72986_A.func_76080_g(0);
+        field_76579_a.field_72986_A.func_76084_b(false);
+        field_76579_a.field_72986_A.func_76090_f(0);
+        field_76579_a.field_72986_A.func_76069_a(false);
+    }
+
+    public boolean canDoLightning(net.minecraft.world.chunk.Chunk chunk)
+    {
+        return true;
+    }
+
+    public boolean canDoRainSnowIce(net.minecraft.world.chunk.Chunk chunk)
+    {
+        return true;
+    }
+
     public void func_186061_a(EntityPlayerMP p_186061_1_)
     {
     }
