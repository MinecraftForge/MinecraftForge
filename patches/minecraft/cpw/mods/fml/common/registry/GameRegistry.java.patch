--- ../src_base/minecraft/cpw/mods/fml/common/registry/GameRegistry.java
+++ ../src_work/minecraft/cpw/mods/fml/common/registry/GameRegistry.java
@@ -12,6 +12,7 @@
 
 package cpw.mods.fml.common.registry;
 
+import java.io.File;
 import java.lang.reflect.Constructor;
 import java.util.List;
 import java.util.Map;
@@ -31,11 +32,21 @@
 import net.minecraft.item.crafting.IRecipe;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldType;
 import net.minecraft.world.biome.BiomeGenBase;
 import net.minecraft.world.chunk.IChunkProvider;
+// MCPC+ start
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import org.bukkit.Location;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.Main;
+import net.minecraft.entity.player.EntityPlayerMP;
+// MCPC+ end
 
 import com.google.common.base.Function;
 import com.google.common.collect.ArrayListMultimap;
@@ -68,15 +79,82 @@
     private static List<ICraftingHandler> craftingHandlers = Lists.newArrayList();
     private static List<IPickupNotifier> pickupHandlers = Lists.newArrayList();
     private static List<IPlayerTracker> playerTrackers = Lists.newArrayList();
-
+    // MCPC+ start
+    private static org.bukkit.configuration.file.YamlConfiguration configuration = MinecraftServer.configuration;
+    private static Map<Integer, List<BannedItem>> bannedItemsCache = new HashMap();
+    // MCPC+ end
     /**
      * Register a world generator - something that inserts new block types into the world
      *
      * @param generator
      */
+    static 
+    {
+        // init banned items
+        if (configuration.getBoolean("mcpc.enable-banned-items"))
+        {
+            for (String bannedData : configuration.getStringList("mcpc.banned-item-IDs")) {
+                int seperator = bannedData.indexOf(':');
+                if (seperator > 0 && (bannedData.length() - 1) > seperator)
+                {
+                    int id = Integer.parseInt(bannedData.substring(0, seperator));
+                    int meta = Integer.parseInt(bannedData.substring(seperator + 1, bannedData.length()));
+                    if (bannedItemsCache.containsKey(id))
+                    {
+                        bannedItemsCache.get(id).add(new BannedItem(id, meta));
+                    }
+                    else
+                    {
+                        List bannedItems = new ArrayList();
+                        bannedItems.add(new BannedItem(id, meta));
+                        bannedItemsCache.put(id, bannedItems);
+                    }
+                    FMLLog.info("Banning" + " item ID " +id);
+                }
+                else
+                {
+                    int id = Integer.parseInt(bannedData);
+                    if (bannedItemsCache.containsKey(id))
+                    {
+                        bannedItemsCache.get(id).add(new BannedItem(id, -1));
+                    }
+                    else
+                    {
+                        List bannedItems = new ArrayList();
+                        bannedItems.add(new BannedItem(id, -1));
+                        bannedItemsCache.put(id, bannedItems);
+                    }
+                    FMLLog.info("Banning" + " item ID " +id);
+                }
+            }
+        }
+    }
+
     public static void registerWorldGenerator(IWorldGenerator generator)
     {
-        worldGenerators.add(generator);
+        // MCPC+ start - add config options to enable/disable mod world generators
+        String modId = Loader.instance().activeModContainer().getModId();
+        modId = modId.replaceAll("[^A-Za-z0-9]", ""); // remove all non-digits/alphanumeric
+        modId.replace(" ", "_");
+        String generatorName = modId + "-" + generator.getClass().getSimpleName();
+        if (!configuration.isBoolean("world-settings.default.worldgen-" + generatorName))
+                configuration.set("world-settings.default.worldgen-" + generatorName, true);
+        boolean generatorEnabled = configuration.getBoolean("world-settings.default.worldgen-" + generatorName);
+        try {
+            configuration.save((File) MinecraftServer.configFile);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        if (!generatorEnabled)
+        {
+            FMLLog.info(Loader.instance().activeModContainer().getModId() + " world generator " + generator + " is DISABLED. Skipping registration.");
+        }
+        else 
+        {
+            FMLLog.info(Loader.instance().activeModContainer().getModId() + " registered world generator " + generator);
+            worldGenerators.add(generator);
+        }
+        // MCPC+ end
     }
 
     /**
@@ -148,6 +226,7 @@
      */
     public static void registerItem(net.minecraft.item.Item item, String name, String modId)
     {
+        GameRegistry.registerMaterial(item, name, modId); // MCPC+ - register bukkit material
         GameData.setName(item, name, modId);
     }
 
@@ -235,9 +314,37 @@
         blockRegistry.put(Loader.instance().activeModContainer(), (BlockProxy) block);
     }
 
+    // MCPC+ start - register bukkit material names for modded items/blocks
+    /**
+     * Register the specified Material with a mod specific name : overrides the standard type XID name
+     * @param item The material to register
+     * @param name The material-unique name to register it as - null will default to modId_itemId
+     * @param modId An optional modId that will "own" this block - generally used by multi-mod systems
+     * where one mod should "own" all the blocks of all the mods, null defaults to the active mod
+     */
+    public static void registerMaterial(net.minecraft.item.Item item, String name, String modId)
+    {
+        if (name != null)
+        {
+            if (modId == null)
+               modId = Loader.instance().activeModContainer().getModId();
+            String materialName = modId + "_" + name;
+            org.bukkit.Material.setMaterialName(item.itemID, materialName);
+        }
+        else 
+        {
+            if (modId == null)
+                modId = Loader.instance().activeModContainer().getModId();
+            String materialName = modId + "_" + String.valueOf(item.itemID);
+            org.bukkit.Material.setMaterialName(item.itemID, materialName);
+        }
+    }
+
+    // Check to see if the item ID is banned before registering it
     public static void addRecipe(ItemStack output, Object... params)
     {
-        addShapedRecipe(output, params);
+        if (output != null && !isItemBanned(output))
+            addShapedRecipe(output, params);
     }
 
     public static IRecipe addShapedRecipe(ItemStack output, Object... params)
@@ -247,7 +354,8 @@
 
     public static void addShapelessRecipe(ItemStack output, Object... params)
     {
-        CraftingManager.getInstance().addShapelessRecipe(output, params);
+        if (output != null && !isItemBanned(output))
+            CraftingManager.getInstance().addShapelessRecipe(output, params);
     }
 
     public static void addRecipe(IRecipe recipe)
@@ -257,8 +365,29 @@
 
     public static void addSmelting(int input, ItemStack output, float xp)
     {
-        FurnaceRecipes.smelting().addSmelting(input, output, xp);
-    }
+        if (!isItemBanned(output))
+            FurnaceRecipes.smelting().addSmelting(input, output, xp);
+    }
+
+    public static boolean isItemBanned(ItemStack itemstack) {
+        if (configuration.getBoolean("mcpc.enable-banned-items") && itemstack != null)
+        {
+            if (bannedItemsCache.containsKey(itemstack.itemID))
+            {
+                List<BannedItem> bannedItems = bannedItemsCache.get(itemstack.itemID);
+                for (int i = 0; i < bannedItems.size(); i++)
+                {
+                    BannedItem block = bannedItems.get(i);
+                    if (block.blockID == itemstack.itemID && (block.meta == itemstack.getItemDamage() || block.meta == -1))
+                    {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+    // MCPC+ end
 
     public static void registerTileEntity(Class<? extends TileEntity> tileEntityClass, String id)
     {
@@ -381,6 +510,11 @@
             try
             {
                 tracker.onPlayerChangedDimension(player);
+                // MCPC+ start - update compassTarget to new world when changing dimensions or it will leave a reference to the last world object causing a memory leak
+                // This is required for mods that implement their own dimension transfer methods which bypass ServerConfigurationManager
+                EntityPlayerMP playermp = (EntityPlayerMP)player;
+                playermp.compassTarget = new Location(playermp.worldObj.getWorld(), playermp.posX, playermp.posY, playermp.posZ);
+                // MCPC+ end
             }
             catch (Exception e)
             {
@@ -433,7 +567,8 @@
 	 */
 	public static void registerCustomItemStack(String name, ItemStack itemStack)
 	{
-	    GameData.registerCustomItemStack(name, itemStack);
+	    if (!isItemBanned(itemStack))
+	        GameData.registerCustomItemStack(name, itemStack);
 	}
 	/**
 	 * Lookup an itemstack based on mod and name. It will create "default" itemstacks from blocks and items if no
