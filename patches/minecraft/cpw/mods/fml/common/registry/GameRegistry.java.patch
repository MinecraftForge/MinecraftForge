--- ../src_base/minecraft/cpw/mods/fml/common/registry/GameRegistry.java
+++ ../src_work/minecraft/cpw/mods/fml/common/registry/GameRegistry.java
@@ -12,7 +12,9 @@
 
 package cpw.mods.fml.common.registry;
 
+import java.io.File;
 import java.lang.reflect.Constructor;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -31,11 +33,16 @@
 import net.minecraft.item.crafting.IRecipe;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldType;
 import net.minecraft.world.biome.BiomeGenBase;
 import net.minecraft.world.chunk.IChunkProvider;
+// MCPC+ start
+import org.bukkit.Location;
+import net.minecraft.entity.player.EntityPlayerMP;
+// MCPC+ end
 
 import com.google.common.base.Function;
 import com.google.common.collect.ArrayListMultimap;
@@ -68,6 +75,10 @@
     private static List<ICraftingHandler> craftingHandlers = Lists.newArrayList();
     private static List<IPickupNotifier> pickupHandlers = Lists.newArrayList();
     private static List<IPlayerTracker> playerTrackers = Lists.newArrayList();
+    // MCPC+ start
+    private static Map<String, Boolean> configWorldGenCache = new HashMap<String, Boolean>();
+    private static Map<String, String> worldGenMap = new HashMap<String, String>();
+    // MCPC+ end
 
     /**
      * Register a world generator - something that inserts new block types into the world
@@ -76,7 +87,13 @@
      */
     public static void registerWorldGenerator(IWorldGenerator generator)
     {
+        // MCPC+ start - mod id's are not available during generateWorld so we must capture them here
+        String modId = Loader.instance().activeModContainer().getModId();
+        modId = modId.replaceAll("[^A-Za-z0-9]", ""); // remove all non-digits/alphanumeric
+        modId.replace(" ", "_");
         worldGenerators.add(generator);
+        worldGenMap.put(generator.getClass().getName(), modId);
+        // MCPC+ end
     }
 
     /**
@@ -97,11 +114,28 @@
         long zSeed = fmlRandom.nextLong() >> 2 + 1L;
         long chunkSeed = (xSeed * chunkX + zSeed * chunkZ) ^ worldSeed;
 
+        boolean before = ((net.minecraft.world.WorldServer)world).theChunkProviderServer.loadChunkOnProvideRequest; // MCPC+ store value
+        ((net.minecraft.world.WorldServer)world).theChunkProviderServer.loadChunkOnProvideRequest = true; // MCPC+ load chunks on provide requests
         for (IWorldGenerator generator : worldGenerators)
         {
-            fmlRandom.setSeed(chunkSeed);
-            generator.generate(fmlRandom, chunkX, chunkZ, world, chunkGenerator, chunkProvider);
-        }
+        // MCPC+ start
+            if (!configWorldGenCache.containsKey(generator.getClass().getName()))
+            {
+                String modId = worldGenMap.get(generator.getClass().getName());
+                String generatorName = "";
+                generatorName = modId + "-" + generator.getClass().getSimpleName();
+                boolean generatorEnabled = world.mcpcConfig.getBoolean("worldgen-" + generatorName, true);
+                configWorldGenCache.put(generator.getClass().getName(), generatorEnabled);
+            }
+            if (configWorldGenCache.get(generator.getClass().getName()))
+            {
+                fmlRandom.setSeed(chunkSeed);
+                generator.generate(fmlRandom, chunkX, chunkZ, world, chunkGenerator, chunkProvider);
+            }
+        }
+        world.mcpcConfig.save();
+        ((net.minecraft.world.WorldServer)world).theChunkProviderServer.loadChunkOnProvideRequest = before; // reset
+        // MCPC+ end
     }
 
     /**
@@ -148,6 +182,7 @@
      */
     public static void registerItem(net.minecraft.item.Item item, String name, String modId)
     {
+        GameRegistry.registerMaterial(item, name, modId); // MCPC+ - register bukkit material
         GameData.setName(item, name, modId);
     }
 
@@ -235,6 +270,33 @@
         blockRegistry.put(Loader.instance().activeModContainer(), (BlockProxy) block);
     }
 
+    // MCPC+ start - register bukkit material names for modded items/blocks
+    /**
+     * Register the specified Material with a mod specific name : overrides the standard type XID name
+     * @param item The material to register
+     * @param name The material-unique name to register it as - null will default to modId_itemId
+     * @param modId An optional modId that will "own" this block - generally used by multi-mod systems
+     * where one mod should "own" all the blocks of all the mods, null defaults to the active mod
+     */
+    public static void registerMaterial(net.minecraft.item.Item item, String name, String modId)
+    {
+        if (name != null)
+        {
+            if (modId == null)
+               modId = Loader.instance().activeModContainer().getModId();
+            String materialName = modId + "_" + name;
+            org.bukkit.Material.setMaterialName(item.itemID, materialName, false);
+        }
+        else 
+        {
+            if (modId == null)
+                modId = Loader.instance().activeModContainer().getModId();
+            String materialName = modId + "_" + String.valueOf(item.itemID);
+            org.bukkit.Material.setMaterialName(item.itemID, materialName, false);
+        }
+    }
+    // MCPC+ end
+
     public static void addRecipe(ItemStack output, Object... params)
     {
         addShapedRecipe(output, params);
@@ -381,6 +443,11 @@
             try
             {
                 tracker.onPlayerChangedDimension(player);
+                // MCPC+ start - update compassTarget to new world when changing dimensions or it will leave a reference to the last world object causing a memory leak
+                // This is required for mods that implement their own dimension transfer methods which bypass ServerConfigurationManager
+                EntityPlayerMP playermp = (EntityPlayerMP)player;
+                playermp.compassTarget = new Location(playermp.worldObj.getWorld(), playermp.posX, playermp.posY, playermp.posZ);
+                // MCPC+ end
             }
             catch (Exception e)
             {
