--- ../src_base/minecraft/net/minecraft/src/EntityMinecart.java	0000-00-00 00:00:00.000000000 -0000
+++ ../src_work/minecraft/net/minecraft/src/EntityMinecart.java	0000-00-00 00:00:00.000000000 -0000
@@ -1,18 +1,23 @@
 package net.minecraft.src;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
 
+import net.minecraft.src.forge.ForgeHooks;
+import net.minecraft.src.forge.IMinecartCollisionHandler;
+import net.minecraft.src.forge.MinecraftForge;
+
 public class EntityMinecart extends Entity
     implements IInventory
 {
-    private ItemStack cargoItems[];
-    private int fuel;
-    private boolean field_856_i;
+    protected ItemStack cargoItems[];
+    protected int fuel;
+    protected boolean field_856_i;
     public int minecartType;
     public double pushX;
     public double pushZ;
-    private static final int field_855_j[][][] =
+    protected static final int field_855_j[][][] =
     {
         {
             {
@@ -76,16 +81,36 @@
             }
         }
     };
-    private int minecartPosRotationIncrements;
-    private double minecartX;
-    private double minecartY;
-    private double minecartZ;
-    private double minecartYaw;
-    private double minecartPitch;
-    private double velocityX;
-    private double velocityY;
-    private double velocityZ;
-
+    protected int minecartPosRotationIncrements;
+    protected double minecartX;
+    protected double minecartY;
+    protected double minecartZ;
+    protected double minecartYaw;
+    protected double minecartPitch;
+    protected double velocityX;
+    protected double velocityY;
+    protected double velocityZ;
+    
+    /*Forge: Minecart Compatibility Layer Integration.
+     */
+    public static float defaultMaxSpeedRail = 0.4f;
+    public static float defaultMaxSpeedGround = 0.4f;
+    public static float defaultMaxSpeedAirLateral = 0.4f;
+    public static float defaultMaxSpeedAirVertical = -1f;
+    public static double defaultDragAir = 0.94999998807907104D;
+    protected boolean canUseRail = true;
+    protected boolean canBePushed = true;
+    private static IMinecartCollisionHandler collisionHandler = null;
+
+    /*
+     * Instance versions of the above physics properties
+     */
+    protected float maxSpeedRail;
+    protected float maxSpeedGround;
+    protected float maxSpeedAirLateral;
+    protected float maxSpeedAirVertical;
+    protected double dragAir;  
+    
     public EntityMinecart(World world)
     {
         super(world);
@@ -95,6 +120,18 @@
         preventEntitySpawning = true;
         setSize(0.98F, 0.7F);
         yOffset = height / 2.0F;
+        
+        maxSpeedRail = defaultMaxSpeedRail;
+        maxSpeedGround = defaultMaxSpeedGround;
+        maxSpeedAirLateral = defaultMaxSpeedAirLateral;
+        maxSpeedAirVertical = defaultMaxSpeedAirVertical;
+        dragAir = defaultDragAir;
+    }
+    
+    public EntityMinecart(World world, int type)
+    {
+    	this(world);
+    	minecartType = type;
     }
 
     protected boolean canTriggerWalking()
@@ -112,17 +149,27 @@
 
     public AxisAlignedBB getCollisionBox(Entity entity)
     {
+    	if (getCollisionHandler() != null)
+    	{
+    		return getCollisionHandler().getCollisionBox(this, entity);
+    	}
+    	
         return entity.boundingBox;
     }
 
     public AxisAlignedBB getBoundingBox()
     {
+    	if (getCollisionHandler() != null)
+    	{
+    		return getCollisionHandler().getBoundingBox(this);
+    	}
+    	
         return null;
     }
 
     public boolean canBePushed()
     {
-        return true;
+    	return canBePushed;
     }
 
     public EntityMinecart(World world, double d, double d1, double d2,
@@ -161,49 +208,8 @@
                 riddenByEntity.mountEntity(this);
             }
             setEntityDead();
-            dropItemWithOffset(Item.minecartEmpty.shiftedIndex, 1, 0.0F);
-            if (minecartType == 1)
-            {
-                EntityMinecart entityminecart = this;
-                label0:
-                for (int j = 0; j < entityminecart.getSizeInventory(); j++)
-                {
-                    ItemStack itemstack = entityminecart.getStackInSlot(j);
-                    if (itemstack == null)
-                    {
-                        continue;
-                    }
-                    float f = rand.nextFloat() * 0.8F + 0.1F;
-                    float f1 = rand.nextFloat() * 0.8F + 0.1F;
-                    float f2 = rand.nextFloat() * 0.8F + 0.1F;
-                    do
-                    {
-                        if (itemstack.stackSize <= 0)
-                        {
-                            continue label0;
-                        }
-                        int k = rand.nextInt(21) + 10;
-                        if (k > itemstack.stackSize)
-                        {
-                            k = itemstack.stackSize;
-                        }
-                        itemstack.stackSize -= k;
-                        EntityItem entityitem = new EntityItem(worldObj, posX + (double)f, posY + (double)f1, posZ + (double)f2, new ItemStack(itemstack.itemID, k, itemstack.getItemDamage()));
-                        float f3 = 0.05F;
-                        entityitem.motionX = (float)rand.nextGaussian() * f3;
-                        entityitem.motionY = (float)rand.nextGaussian() * f3 + 0.2F;
-                        entityitem.motionZ = (float)rand.nextGaussian() * f3;
-                        worldObj.spawnEntityInWorld(entityitem);
-                    }
-                    while (true);
-                }
-
-                dropItemWithOffset(Block.chest.blockID, 1, 0.0F);
-            }
-            else if (minecartType == 2)
-            {
-                dropItemWithOffset(Block.stoneOvenIdle.blockID, 1, 0.0F);
-            }
+            
+            dropCartAsItem();
         }
         return true;
     }
@@ -268,7 +274,7 @@
         {
             func_41024_b(func_41025_i() - 1);
         }
-        if (isMinecartPowered() && rand.nextInt(4) == 0)
+        if (isMinecartPowered() && rand.nextInt(4) == 0 && minecartType == 2 && getClass() == EntityMinecart.class)
         {
             worldObj.spawnParticle("largesmoke", posX, posY + 0.80000000000000004D, posZ, 0.0D, 0.0D, 0.0D);
         }
@@ -309,22 +315,18 @@
         double d2 = 0.40000000000000002D;
         double d4 = 0.0078125D;
         int l = worldObj.getBlockId(i, j, k);
-        if (BlockRail.isRailBlock(l))
+        if (canUseRail() && BlockRail.isRailBlock(l))
         {
             Vec3D vec3d = func_514_g(posX, posY, posZ);
-            int i1 = worldObj.getBlockMetadata(i, j, k);
+            int i1 = ((BlockRail)Block.blocksList[l]).getBasicRailMetadata(worldObj, this, i, j, k);
             posY = j;
             boolean flag = false;
             boolean flag1 = false;
             if (l == Block.railPowered.blockID)
             {
-                flag = (i1 & 8) != 0;
+                flag = (worldObj.getBlockMetadata(i, j, k) & 8) != 0;
                 flag1 = !flag;
             }
-            if (((BlockRail)Block.blocksList[l]).getIsPowered())
-            {
-                i1 &= 7;
-            }
             if (i1 >= 2 && i1 <= 5)
             {
                 posY = j + 1;
@@ -358,7 +360,7 @@
             double d13 = Math.sqrt(motionX * motionX + motionZ * motionZ);
             motionX = (d13 * d9) / d11;
             motionZ = (d13 * d10) / d11;
-            if (flag1)
+            if (flag1 && shouldDoRailFunctions())
             {
                 double d16 = Math.sqrt(motionX * motionX + motionZ * motionZ);
                 if (d16 < 0.029999999999999999D)
@@ -401,30 +403,9 @@
             posX = d18 + d9 * d17;
             posZ = d19 + d10 * d17;
             setPosition(posX, posY + (double)yOffset, posZ);
-            double d23 = motionX;
-            double d25 = motionZ;
-            if (riddenByEntity != null)
-            {
-                d23 *= 0.75D;
-                d25 *= 0.75D;
-            }
-            if (d23 < -d2)
-            {
-                d23 = -d2;
-            }
-            if (d23 > d2)
-            {
-                d23 = d2;
-            }
-            if (d25 < -d2)
-            {
-                d25 = -d2;
-            }
-            if (d25 > d2)
-            {
-                d25 = d2;
-            }
-            moveEntity(d23, 0.0D, d25);
+            
+            moveMinecartOnRail(i, j, k);
+            
             if (ai[0][1] != 0 && MathHelper.floor_double(posX) - i == ai[0][0] && MathHelper.floor_double(posZ) - k == ai[0][2])
             {
                 setPosition(posX, posY + (double)ai[0][1], posZ);
@@ -433,39 +414,9 @@
             {
                 setPosition(posX, posY + (double)ai[1][1], posZ);
             }
-            if (riddenByEntity != null)
-            {
-                motionX *= 0.99699997901916504D;
-                motionY *= 0.0D;
-                motionZ *= 0.99699997901916504D;
-            }
-            else
-            {
-                if (minecartType == 2)
-                {
-                    double d27 = MathHelper.sqrt_double(pushX * pushX + pushZ * pushZ);
-                    if (d27 > 0.01D)
-                    {
-                        pushX /= d27;
-                        pushZ /= d27;
-                        double d29 = 0.040000000000000001D;
-                        motionX *= 0.80000001192092896D;
-                        motionY *= 0.0D;
-                        motionZ *= 0.80000001192092896D;
-                        motionX += pushX * d29;
-                        motionZ += pushZ * d29;
-                    }
-                    else
-                    {
-                        motionX *= 0.89999997615814209D;
-                        motionY *= 0.0D;
-                        motionZ *= 0.89999997615814209D;
-                    }
-                }
-                motionX *= 0.95999997854232788D;
-                motionY *= 0.0D;
-                motionZ *= 0.95999997854232788D;
-            }
+            
+            applyDragAndPushForces();
+            
             Vec3D vec3d1 = func_514_g(posX, posY, posZ);
             if (vec3d1 != null && vec3d != null)
             {
@@ -486,26 +437,14 @@
                 motionX = d15 * (double)(k1 - i);
                 motionZ = d15 * (double)(l1 - k);
             }
-            if (minecartType == 2)
+            
+            updatePushForces();
+            
+            if (shouldDoRailFunctions())
             {
-                double d30 = MathHelper.sqrt_double(pushX * pushX + pushZ * pushZ);
-                if (d30 > 0.01D && motionX * motionX + motionZ * motionZ > 0.001D)
-                {
-                    pushX /= d30;
-                    pushZ /= d30;
-                    if (pushX * motionX + pushZ * motionZ < 0.0D)
-                    {
-                        pushX = 0.0D;
-                        pushZ = 0.0D;
-                    }
-                    else
-                    {
-                        pushX = motionX;
-                        pushZ = motionZ;
-                    }
-                }
+            	((BlockRail)Block.blocksList[l]).onMinecartPass(worldObj, this, i, j, k);
             }
-            if (flag)
+            if (flag && shouldDoRailFunctions())
             {
                 double d31 = Math.sqrt(motionX * motionX + motionZ * motionZ);
                 if (d31 > 0.01D)
@@ -540,35 +479,7 @@
         }
         else
         {
-            if (motionX < -d2)
-            {
-                motionX = -d2;
-            }
-            if (motionX > d2)
-            {
-                motionX = d2;
-            }
-            if (motionZ < -d2)
-            {
-                motionZ = -d2;
-            }
-            if (motionZ > d2)
-            {
-                motionZ = d2;
-            }
-            if (onGround)
-            {
-                motionX *= 0.5D;
-                motionY *= 0.5D;
-                motionZ *= 0.5D;
-            }
-            moveEntity(motionX, motionY, motionZ);
-            if (!onGround)
-            {
-                motionX *= 0.94999998807907104D;
-                motionY *= 0.94999998807907104D;
-                motionZ *= 0.94999998807907104D;
-            }
+            moveMinecartOffRail(i, j, k);
         }
         rotationPitch = 0.0F;
         double d6 = prevPosX - posX;
@@ -590,7 +501,20 @@
             field_856_i = !field_856_i;
         }
         setRotation(rotationYaw, rotationPitch);
-        List list = worldObj.getEntitiesWithinAABBExcludingEntity(this, boundingBox.expand(0.20000000298023224D, 0.0D, 0.20000000298023224D));
+        
+        AxisAlignedBB box = null;
+        
+        if (getCollisionHandler() != null)
+        {
+        	box = getCollisionHandler().getMinecartCollisionBox(this);
+        }
+        else
+        {
+        
+        	box = boundingBox.expand(0.20000000298023224D, 0.0D, 0.20000000298023224D);
+        }
+        
+        List list = worldObj.getEntitiesWithinAABBExcludingEntity(this, box);
         if (list != null && list.size() > 0)
         {
             for (int j1 = 0; j1 < list.size(); j1++)
@@ -610,15 +534,8 @@
             }
             riddenByEntity = null;
         }
-        if (fuel > 0)
-        {
-            fuel--;
-        }
-        if (fuel <= 0)
-        {
-            pushX = pushZ = 0.0D;
-        }
-        setMinecartPowered(fuel > 0);
+        updateFuel();
+        ForgeHooks.onMinecartUpdate(this, i, j, k);
     }
 
     public Vec3D func_515_a(double d, double d1, double d2, double d3)
@@ -633,11 +550,7 @@
         int l = worldObj.getBlockId(i, j, k);
         if (BlockRail.isRailBlock(l))
         {
-            int i1 = worldObj.getBlockMetadata(i, j, k);
-            if (((BlockRail)Block.blocksList[l]).getIsPowered())
-            {
-                i1 &= 7;
-            }
+            int i1 = ((BlockRail)Block.blocksList[l]).getBasicRailMetadata(worldObj, this, i, j, k);
             d1 = j;
             if (i1 >= 2 && i1 <= 5)
             {
@@ -679,12 +592,8 @@
         int l = worldObj.getBlockId(i, j, k);
         if (BlockRail.isRailBlock(l))
         {
-            int i1 = worldObj.getBlockMetadata(i, j, k);
+        	int i1 = ((BlockRail)Block.blocksList[l]).getBasicRailMetadata(worldObj, this, i, j, k);
             d1 = j;
-            if (((BlockRail)Block.blocksList[l]).getIsPowered())
-            {
-                i1 &= 7;
-            }
             if (i1 >= 2 && i1 <= 5)
             {
                 d1 = j + 1;
@@ -739,13 +648,13 @@
     protected void writeEntityToNBT(NBTTagCompound nbttagcompound)
     {
         nbttagcompound.setInteger("Type", minecartType);
-        if (minecartType == 2)
+        if (isPoweredCart())
         {
             nbttagcompound.setDouble("PushX", pushX);
             nbttagcompound.setDouble("PushZ", pushZ);
-            nbttagcompound.setShort("Fuel", (short)fuel);
+            nbttagcompound.setInteger("Fuel", fuel);
         }
-        else if (minecartType == 1)
+        if (getSizeInventory() > 0)
         {
             NBTTagList nbttaglist = new NBTTagList();
             for (int i = 0; i < cargoItems.length; i++)
@@ -766,13 +675,13 @@
     protected void readEntityFromNBT(NBTTagCompound nbttagcompound)
     {
         minecartType = nbttagcompound.getInteger("Type");
-        if (minecartType == 2)
+        if (isPoweredCart())
         {
             pushX = nbttagcompound.getDouble("PushX");
             pushZ = nbttagcompound.getDouble("PushZ");
-            fuel = nbttagcompound.getShort("Fuel");
+            fuel = nbttagcompound.getInteger("Fuel");
         }
-        else if (minecartType == 1)
+        if (getSizeInventory() > 0)
         {
             NBTTagList nbttaglist = nbttagcompound.getTagList("Items");
             cargoItems = new ItemStack[getSizeInventory()];
@@ -795,6 +704,12 @@
 
     public void applyEntityCollision(Entity entity)
     {
+    	ForgeHooks.onMinecartEntityCollision(this, entity);
+    	if (getCollisionHandler() != null)
+    	{
+    		getCollisionHandler().onEntityCollision(this, entity);
+    		return;
+    	}
         if (worldObj.multiplayerWorld)
         {
             return;
@@ -803,7 +718,7 @@
         {
             return;
         }
-        if ((entity instanceof EntityLiving) && !(entity instanceof EntityPlayer) && minecartType == 0 && motionX * motionX + motionZ * motionZ > 0.01D && riddenByEntity == null && entity.ridingEntity == null)
+        if ((entity instanceof EntityLiving) && !(entity instanceof EntityPlayer) && canBeRidden() && motionX * motionX + motionZ * motionZ > 0.01D && riddenByEntity == null && entity.ridingEntity == null)
         {
             entity.mountEntity(this);
         }
@@ -841,7 +756,7 @@
                 }
                 double d7 = entity.motionX + motionX;
                 double d8 = entity.motionZ + motionZ;
-                if (((EntityMinecart)entity).minecartType == 2 && minecartType != 2)
+                if (((EntityMinecart)entity).isPoweredCart() && !isPoweredCart())
                 {
                     motionX *= 0.20000000298023224D;
                     motionZ *= 0.20000000298023224D;
@@ -849,7 +764,7 @@
                     entity.motionX *= 0.94999998807907104D;
                     entity.motionZ *= 0.94999998807907104D;
                 }
-                else if (((EntityMinecart)entity).minecartType != 2 && minecartType == 2)
+                else if (!((EntityMinecart)entity).isPoweredCart() && isPoweredCart())
                 {
                     entity.motionX *= 0.20000000298023224D;
                     entity.motionZ *= 0.20000000298023224D;
@@ -879,7 +794,7 @@
 
     public int getSizeInventory()
     {
-        return 27;
+        return (minecartType == 1 && getClass() == EntityMinecart.class ? 27 : 0);
     }
 
     public ItemStack getStackInSlot(int i)
@@ -935,7 +850,11 @@
 
     public boolean interact(EntityPlayer entityplayer)
     {
-        if (minecartType == 0)
+    	if (!ForgeHooks.onMinecartInteract(this, entityplayer))
+    	{
+    		return true;
+    	}
+        if (canBeRidden())
         {
             if (riddenByEntity != null && (riddenByEntity instanceof EntityPlayer) && riddenByEntity != entityplayer)
             {
@@ -946,14 +865,14 @@
                 entityplayer.mountEntity(this);
             }
         }
-        else if (minecartType == 1)
+        else if (getSizeInventory() > 0)
         {
             if (!worldObj.multiplayerWorld)
             {
                 entityplayer.displayGUIChest(this);
             }
         }
-        else if (minecartType == 2)
+        else if (minecartType == 2 && getClass() == EntityMinecart.class)
         {
             ItemStack itemstack = entityplayer.inventory.getCurrentItem();
             if (itemstack != null && itemstack.itemID == Item.coal.shiftedIndex)
@@ -1000,7 +919,7 @@
         return entityplayer.getDistanceSqToEntity(this) <= 64D;
     }
 
-    protected boolean isMinecartPowered()
+    public boolean isMinecartPowered()
     {
         return (dataWatcher.getWatchableObjectByte(16) & 1) != 0;
     }
@@ -1054,4 +973,382 @@
     {
         return dataWatcher.getWatchableObjectInt(18);
     }
+    
+    /**
+     * Drops the cart as a item. The exact item dropped is defined by getItemDropped().
+     */
+    public void dropCartAsItem()
+    {
+        for(ItemStack item : getItemsDropped())
+        {
+            entityDropItem(item, 0);
+        }
+    }
+    
+    /**
+     * Override this to define which items your cart drops when broken.
+     * This does not include items contained in the inventory,
+     * that is handled elsewhere.
+     * @return A list of items dropped.
+     */
+    public List<ItemStack> getItemsDropped()
+    {
+        List<ItemStack> items = new ArrayList<ItemStack>();
+        items.add(new ItemStack(Item.minecartEmpty));
+        
+        switch(minecartType)
+        {
+            case 1:
+                items.add(new ItemStack(Block.chest));
+                break;
+            case 2:
+                items.add(new ItemStack(Block.stoneOvenIdle));
+                break;
+        }
+        return items;
+    }
+    
+    /**
+     * This function returns an ItemStack that represents this cart.
+     * This should be an ItemStack that can be used by the player to place the cart.
+     * This is the item that was registered with the cart via the registerMinecart function,
+     * but is not necessary the item the cart drops when destroyed.
+     * @return An ItemStack that can be used to place the cart.
+     */
+    public ItemStack getCartItem()
+    {
+        return MinecraftForge.getItemForCart(this);
+    }
+    
+    /**
+     * Returns true if this cart is self propelled.
+     * @return True if powered.
+     */
+    public boolean isPoweredCart()
+    {
+        return minecartType == 2 && getClass() == EntityMinecart.class;
+    }
+
+    /** 
+     * Returns true if this cart is a storage cart
+     * Some carts may have inventories but not be storage carts
+     * and some carts without inventories may be storage carts.
+     * @return True if this cart should be classified as a storage cart.
+     */
+    public boolean isStorageCart()
+    {
+        return minecartType == 1 && getClass() == EntityMinecart.class;
+    }
+
+    /**
+     * Returns true if this cart can be ridden by an Entity.
+     * @return True if this cart can be ridden.
+     */
+    public boolean canBeRidden()
+    {
+        if(minecartType == 0 && getClass() == EntityMinecart.class)
+        {
+            return true;
+        }
+        return false;
+    }
+    
+    /** 
+     * Returns true if this cart can currently use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @return True if the minecart can use rails.
+     */
+    public boolean canUseRail()
+    {
+        return canUseRail;
+    }
+
+    /**
+     * Set whether the minecart can use rails.
+     * This function is mainly used to gracefully detach a minecart from a rail.
+     * @param use Whether the minecart can currently use rails.
+     */
+    public void setCanUseRail(boolean use)
+    {
+        canUseRail = use;
+    }    
+        
+    /** 
+     * Return false if this cart should not call IRail.onMinecartPass() and should ignore Powered Rails.
+     * @return True if this cart should call IRail.onMinecartPass().
+     */
+    public boolean shouldDoRailFunctions()
+    {
+        return true;
+    }
+    
+    /**
+     * Simply returns the minecartType variable.
+     * @return minecartType
+     */
+    public int getMinecartType()
+    {
+        return minecartType;
+    }
+    
+    /**
+     * Gets the current global Minecart Collision handler if none
+     * is registered, returns null
+     * @return The collision handler or null
+     */
+    public static IMinecartCollisionHandler getCollisionHandler()
+    {
+    	return collisionHandler;
+    }
+    
+    /**
+     * Sets the global Minecart Collision handler, overwrites any
+     * that is currently set.
+     * @param handler The new handler
+     */
+    public static void setCollisionHandler(IMinecartCollisionHandler handler)
+    {
+    	collisionHandler = handler;
+    }
+    
+    /**
+     * Carts should return their drag factor here
+     * @return The drag rate.
+     */
+    protected double getDrag()
+    {
+        if(riddenByEntity != null)
+        {
+            return 0.99699997901916504D;
+        }
+        return 0.95999997854232788D;
+    }   
+    
+    /**
+     * Moved to allow overrides.
+     * This code applies drag and updates push forces.
+     */
+    protected void applyDragAndPushForces()
+    {
+        if(isPoweredCart())
+        {
+            double d27 = MathHelper.sqrt_double(pushX * pushX + pushZ * pushZ);
+            if(d27 > 0.01D)
+            {
+                pushX /= d27;
+                pushZ /= d27;
+                double d29 = 0.040000000000000001D;
+                motionX *= 0.80000001192092896D;
+                motionY *= 0.0D;
+                motionZ *= 0.80000001192092896D;
+                motionX += pushX * d29;
+                motionZ += pushZ * d29;
+            } else
+            {
+                motionX *= 0.89999997615814209D;
+                motionY *= 0.0D;
+                motionZ *= 0.89999997615814209D;
+            }
+        }
+        motionX *= getDrag();
+        motionY *= 0.0D;
+        motionZ *= getDrag();
+    }
+    
+    /**
+     * Moved to allow overrides.
+     * This code updates push forces.
+     */
+    protected void updatePushForces()
+    {
+        if(isPoweredCart())
+        {
+            double push = MathHelper.sqrt_double(pushX * pushX + pushZ * pushZ);
+            if(push > 0.01D && motionX * motionX + motionZ * motionZ > 0.001D)
+            {
+                pushX /= push;
+                pushZ /= push;
+                if(pushX * motionX + pushZ * motionZ < 0.0D)
+                {
+                    pushX = 0.0D;
+                    pushZ = 0.0D;
+                } else
+                {
+                    pushX = motionX;
+                    pushZ = motionZ;
+                }
+            }
+        }
+    }
+    
+    /**
+     * Moved to allow overrides.
+     * This code handles minecart movement and speed capping when on a rail.
+     */
+    protected void moveMinecartOnRail(int i, int j, int k)
+    {
+        int id = worldObj.getBlockId(i, j, k);
+        if (!BlockRail.isRailBlock(id))
+        {
+        	return;
+        }
+        float railMaxSpeed = ((BlockRail)Block.blocksList[id]).getRailMaxSpeed(worldObj, this, i, j, k);
+        
+        double maxSpeed = Math.min(railMaxSpeed, getMaxSpeedRail());
+        double d23 = motionX;
+        double d25 = motionZ;
+        if(riddenByEntity != null)
+        {
+            d23 *= 0.75D;
+            d25 *= 0.75D;
+        }
+        if(d23 < -maxSpeed)
+        {
+            d23 = -maxSpeed;
+        }
+        if(d23 > maxSpeed)
+        {
+            d23 = maxSpeed;
+        }
+        if(d25 < -maxSpeed)
+        {
+            d25 = -maxSpeed;
+        }
+        if(d25 > maxSpeed)
+        {
+            d25 = maxSpeed;
+        }
+        moveEntity(d23, 0.0D, d25);
+    }    
+    
+    /**
+     * Moved to allow overrides.
+     * This code handles minecart movement and speed capping when not on a rail.
+     */
+    protected void moveMinecartOffRail(int i, int j, int k)
+    {
+        double d2 = getMaxSpeedGround();
+        if(!onGround)
+        {
+            d2 = getMaxSpeedAirLateral();
+        }
+        if(motionX < -d2)
+        {
+            motionX = -d2;
+        }
+        if(motionX > d2)
+        {
+            motionX = d2;
+        }
+        if(motionZ < -d2)
+        {
+            motionZ = -d2;
+        }
+        if(motionZ > d2)
+        {
+            motionZ = d2;
+        }
+        double moveY = motionY;
+        if(getMaxSpeedAirVertical() > 0 && motionY > getMaxSpeedAirVertical())
+        {
+            moveY = getMaxSpeedAirVertical();
+            if(Math.abs(motionX) < 0.3f && Math.abs(motionZ) < 0.3f)
+            {
+                moveY = 0.15f;
+                motionY = moveY;
+            }
+        }
+        if(onGround)
+        {
+            motionX *= 0.5D;
+            motionY *= 0.5D;
+            motionZ *= 0.5D;
+        }
+        moveEntity(motionX, moveY, motionZ);
+        if(!onGround)
+        {
+            motionX *= getDragAir();
+            motionY *= getDragAir();
+            motionZ *= getDragAir();
+        }
+    }
+    
+	/**
+	 * Moved to allow overrides.
+	 * This code applies fuel consumption.
+	 */   
+    protected void updateFuel()
+    {
+        if (fuel > 0)
+        {
+            fuel--;
+        }
+        if (fuel <= 0)
+        {
+            pushX = pushZ = 0.0D;
+        }
+        setMinecartPowered(fuel > 0);
+    }
+    
+    /**
+     * Getters/setters for physics variables
+     */
+    
+    /**
+     * Returns the carts max speed.
+     * Carts going faster than 1.1 cause issues with chunk loading.
+     * Carts cant traverse slopes or corners at greater than 0.5 - 0.6.
+     * This value is compared with the rails max speed to determine
+     * the carts current max speed. A normal rails max speed is 0.4.
+     * @return Carts max speed.
+     */
+    public float getMaxSpeedRail()
+    {
+        return maxSpeedRail;
+    }
+
+    public void setMaxSpeedRail(float value)
+    {
+    	maxSpeedRail = value;
+    }
+    
+    public float getMaxSpeedGround()
+    {
+    	return maxSpeedGround;
+    }
+    
+    public void setMaxSpeedGround(float value)
+    {
+    	maxSpeedGround = value;
+    }
+    
+    public float getMaxSpeedAirLateral()
+    {
+    	return maxSpeedAirLateral;
+    }
+    
+    public void setMaxSpeedAirLateral(float value)
+    {
+    	maxSpeedAirLateral = value;
+    }
+    
+    public float getMaxSpeedAirVertical()
+    {
+    	return maxSpeedAirVertical;
+    }
+    
+    public void setMaxSpeedAirVertical(float value)
+    {
+    	maxSpeedAirVertical = value;
+    }
+    
+    public double getDragAir()
+    {
+    	return dragAir;
+    }
+    
+    public void setDragAir(double value)
+    {
+    	dragAir = value;
+    }
 }
